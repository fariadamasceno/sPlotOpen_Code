---
title: "Project#02 - Build Dataset"
author: "Francesco Maria Sabatini"
date: "4/28/2020"
output: html_document
---

<center>
  ![](https://www.idiv.de/fileadmin/content/Files_sDiv/sDiv_Workshops_Photos_Docs/sDiv_WS_Documents_sPlot/splot-long-rgb.png "sPlot Logo")
</center>
  
    
      
        
**Timestamp:** `r date()`  
**Drafted:** Francesco Maria Sabatini  
**Revised:**  
**Version:** 1.0
  
This report describes how data from the sPlot database have been extracted to build an environmentally-balanced subset. Resampling of plots in the environmental space follows [Bruelheide et al. 2018 NEE](https://www.nature.com/articles/s41559-018-0699-8), and is done elsewhere.  
All data custodians were contacted individually and asked for permission to make a chunk of their data  open-access. Here I only reported the collated answers. 
  
```{r results="hide", message=F, warning=F}
library(tidyverse)
### Conflict with new tibble 3.0.0 - I had to fall back on previous versions of some of the tidyverse packages
#library(devtools)
#install_version("tibble", version = "2.1.3")
#install_version("broom", version = "0.5.5")
#install_version("modelr", version = "0.1.6")
library(openxlsx)
library(knitr)
library(kableExtra)
library(viridis)
library(plotbiomes)

#library(raster)
library(sp)
library(sf)
library(rgdal)
library(rnaturalearth)
library(dggridR)
# library(rgeos)

#save temporary files
write("TMPDIR = /data/sPlot/users/Francesco/_tmp", file=file.path(Sys.getenv('TMPDIR'), '.Renviron'))
write("R_USER = /data/sPlot/users/Francesco/_tmp", file=file.path(Sys.getenv('R_USER'), '.Renviron'))
#rasterOptions(tmpdir="/data/sPlot/users/Francesco/_tmp")
```
## Import and clean data

Import and fix sPlot data. Import and attach database-level information and [GIVD](https://www.givd.info/) codes. 
```{r, cache=T, results="hide", message=F, warning=F}
load("/data/sPlot/releases/sPlot2.1/DT2_20161025.RData")
load("/data/sPlot/releases/sPlot2.1/sPlot_header_20161124.RData")
#fix header data
source("/data/sPlot/users/Francesco/_sPlot_Management/Fix.header.R")
header <- fix.header(header, exclude.sophy = F)
#Import database-level information
databases <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/Databases.out.csv")
```
Import database level answers from custodians. This table reports whether the plots from a given dataset can be released open-access without condition (Yes); whether this is true only for a set of manually selected plots (Conditional); or cannot be used (No).
```{r}
answers <- openxlsx::read.xlsx("_management/resampling_answers.xlsx", sheet = 2)
answers <- answers %>% 
  mutate(`Yes/Conditional/No`=fct_recode(`Yes/Conditional/No`, No="NO", Yes="yes")) %>% 
  # Manually set some dataset to yes
  # Rasmus Revermann and Donald Walker's acceptance is conditional, 
  # but depends on conditions others than the selection of plot.
  mutate(`Yes/Conditional/No`=replace(`Yes/Conditional/No`, 
                                    list=GIVD.ID %in% c("NA-US-014","AF-00-009", 
                                                        "AF-00-006", "00-00-003"),  
                                    values="Yes"))

head(answers)
```

Import IDs of first choice plots, i.e. plots resampled in iteration 1. Load redundant list of plots selected in runs 1-3 of resampling (first choice + reserves), with plot-level specification from dataset custodians wheter a plot is usable (i.e., can be released OA) or not. 
```{r results="hide", message=F, warning=F}
# first choice plot IDs
sel1 <- readr::read_csv("_data/Resampled1.csv")$x

# First choice plots + reserves
usable.plots123 <- readr::read_csv("_output/header.sel.final.csv") %>% 
  mutate(first.choice=PlotObservationID %in% sel1) %>% 
  distinct()

#compute summary
summary.sel.final <- usable.plots123 %>% 
  group_by(`GIVD ID`, Dataset, Custodian, `Deputy custodian`) %>% 
  ### Summarize data at dataset level
  summarize(N.redundant=n(), 
            usable=sum(Usable=="Yes"), 
            not.usable=sum(Usable=="No"), 
            unknown=sum(Usable=="Unknown"), .groups = 'drop') %>% 
  ### total number of plots in a dataset
  left_join(header %>% 
              group_by(`GIVD ID`) %>% 
              summarize(n.tot.plot=n(), .groups = 'drop'),
            by="GIVD ID") %>% 
  ### number of first choice plots
  left_join(header %>% 
              filter(PlotObservationID %in% sel1) %>% 
              group_by(`GIVD ID`) %>% 
              summarize(n.sel.plot=n(), .groups = 'drop'),
            by="GIVD ID") %>% 
  mutate(share.perc=round(n.sel.plot/n.tot.plot*100),1) %>% 
  dplyr::select(`GIVD ID`:`Deputy custodian`, n.tot.plot:share.perc, N.redundant:unknown) 

#check how many first choice plots can be used, and how many need replacement
firstchoice <- usable.plots123 %>% 
  mutate(Usable=forcats::fct_recode(Usable, "No" = "Unknown")) %>% 
  group_by(first.choice, Usable) %>% 
  summarize(n=n(), .groups = 'drop')
```

```{r, echo=F}
knitr::kable(summary.sel.final %>% 
               rename(`Total # plots in DB (A)`=n.tot.plot, 
                      `First choice plots (B)`=n.sel.plot, 
                      `Percentage B/A`=share.perc, 
                      `# First choice + reserves (C)`=N.redundant, 
                      `# of plots in (C) usable`=usable,
                      `# of plots in (C) not_usable`=not.usable,
                      `# of plots in (C) no_info`=unknown), 
             
             caption="Summary of first choice and reserve plots per dataset, with aggregated info on how many plots can be used (i.e., release OA)") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```
Out of the `r length(sel1)` plots selected in the first run of the resampling, `r firstchoice %>% filter(first.choice==T & Usable =="Yes") %>% pull(n)` can be used. The remaining `r firstchoice %>% filter(first.choice==T & Usable =="No") %>% pull(n)` require to be replaced.

## Replace plots not usable with reserves
In those cases where we do not have permission to use a plot selected in resampling run #1 [first.choice], we replace it with a reserve belonging to the same cell in the PCA space grid. Reserves correspond to plots selected in resamplings runs #2 or #3, whose use was approved by the respective custodians. Additionally we considered as usable reserves ALL those plots belonging to datasets whose custodian gave us unconditional permission to use their data.  
PCA is calculated in the environmental space defined by the 30 climatic and soil variables used in Bruelheide et al. 2018 NEE.  

Load PCA data
```{r}
load("_data/plot_data.RData")
pca.grids <- plot_data %>% 
  filter(PlotObservationID %in% header$PlotObservationID) %>% 
  #attach GIVD codes 
  left_join(header %>% 
              distinct(`GIVD ID`,Dataset), 
            by="Dataset") %>% 
  dplyr::select(PlotObservationID,`GIVD ID`, Dataset, 
                cellID, pc1_val, pc2_val) %>% 
  as_tibble() %>% 
  #Attach info on first choice, reserve and usable plots
  mutate(first.choice=PlotObservationID %in% sel1) %>% 
  left_join(usable.plots123 %>% 
              dplyr::select(PlotObservationID, Usable) %>% 
              mutate(Usable=Usable=="Yes"), 
            by="PlotObservationID") %>% 
  mutate(reserve= (!PlotObservationID %in% sel1) & Usable==T) %>% 
  #Consider as usable reserves ALL those plots belonging to datasets whose custodian gave us
  # unconditional permission to use the data
  mutate(Usable=replace(Usable, 
                        list= (is.na(Usable) & 
                                 `GIVD ID` %in% (answers %>% 
                                     filter(`Yes/Conditional/No`=="Yes") %>% 
                                     pull(GIVD.ID))), 
                        values=T)) %>% 
  mutate(reserve=replace(reserve, 
                        list= (first.choice==F & 
                                 `GIVD ID` %in% (answers %>% 
                                     filter(`Yes/Conditional/No`=="Yes") %>% 
                                     pull(GIVD.ID))), 
                        values=T))

head(pca.grids %>% 
       dplyr::select(-pc1_val, -pc2_val))
```

For each non-usable first choice plot, find a reserve from the same grid cell in the PCA space.

```{r}
toreplace <- pca.grids %>% 
  filter(first.choice==T) %>% 
  filter(Usable==F) %>% 
  pull(PlotObservationID)

#number of first choice plots needing replacement
length(toreplace)

set.seed(9999)
selected.reserves <- pca.grids %>% 
  filter(reserve==T) %>% 
  #for each cell, calculate how many reserves would be needed, and how many reserves are available
  left_join(pca.grids %>% 
              group_by(cellID) %>% 
              summarize(n.first=sum(first.choice, na.rm=T),
                        n.first.usable=sum(first.choice*Usable, na.rm=T), 
                        reserve.available=sum(reserve, na.rm=T), .groups = 'drop') %>% 
              mutate(reserve.needed=n.first-n.first.usable),
            by=c("cellID")) %>% 
  filter(reserve.needed>0) %>% 
  # from each cell where >0 reserves are needed, sample randomly n usable reserves, 
  # where n is the minimun between the number of reserves needed and reserves available
  group_by(cellID) %>% 
  mutate(reserve.available=min(reserve.needed, reserve.available)) %>% 
  sample_n(reserve.available)
```

```{r, echo=F}
knitr::kable(selected.reserves %>% 
               dplyr::select(-pc1_val, -pc2_val) %>% 
               ungroup() %>%
               arrange(cellID) %>% 
               slice(1:20),
             caption="Example of selected reserves [first 20 rows shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```

By selecting plots within the same cell in the PCA grid, we can only replace `r nrow(selected.reserves)`, out of the `r length(toreplace)` non-usable first choice plots. 


## Build sPlot OA dataset
### Header
```{r}
header.oa <- header %>% 
  filter(PlotObservationID %in% (usable.plots123 %>%
                                   filter(first.choice==T) %>% 
                                   filter(Usable=="Yes") %>% 
                                     pull(PlotObservationID))) %>% 
  bind_rows(header %>% 
              filter(PlotObservationID %in% selected.reserves$PlotObservationID))
  
```
After merging first choice plots and the corresponding reserves, the database contains `r nrow(header.oa)` plots, stemming from `r header.oa %>% distinct("GIVD ID") %>% nrow()` databases.

Data preparation: adjust header data, select relevant variables, reformat variables into the right classes, correct macroscopic errors.
```{r, warning=F}
header.oa <- header.oa %>% 
    #reformat and rename
  mutate_at(.vars=vars(`Altitude (m)`, `Aspect (°)`, `Slope (°)`), 
            ~as.numeric(.)) %>% 
  mutate_at(.vars=vars(ESY), 
            ~as.character(.)) %>% 
  mutate_at(.vars=vars(Forest:Wetland), 
            ~as.logical(.)) %>% 
  mutate_at(.vars=vars(`Herbs identified (y/n)`, `Mosses identified (y/n)`, `Lichens identified (y/n)`),
            ~ifelse(.=="Y", T, F)) %>% 
  mutate(`Date of recording`=as.Date(`Date of recording`, "%d-%m-%Y") ) %>%
  mutate(CONTINENT=factor(CONTINENT, exclude = " ")) %>% 
  mutate(`Plants recorded`=factor(`Plants recorded`, exclude = "#N/A")) %>% 
  mutate(`Plants recorded`=forcats::fct_recode(`Plants recorded`, 
                                      "All vascular plants"="Complete vegetation",
                                      "All vascular plants"="all vascular plants", 
                                      "All vascular plants"="complete", 
                                      "All vascular plants"="Complete vegetation (including non-terricolous tax",
                                      "All vascular plants"="Vascular plants",
                                      "All woody plants"="Woody plants",
                                      "All woody plants"="All woody species",
                                      "Woody plants >= 10 cm dbh"= "trees>=10cm dbh",
                                      "Woody plants >= 10 cm dbh"= "Woody plants >= 10 cm dbh and domin",
                                      "All trees & dominant understory"="All trees & dominant shrubs",
                                      "Woody plants >= 5 cm dbh"="Woody plants >= 5 cm dbh & dominant",
                                      "Woody plants >= 1 cm dbh" = "Plants >= 1 cm dbh", 
                                      "Only dominant species"="Dominant vascular plants",
                                      "Woody plants >= 1 m height"="trees and shrubs >1 m height"
                                      )) %>% 
  ##correct mistakes
  mutate(`Altitude (m)`=ifelse(`Altitude (m)`< -100, NA, `Altitude (m)`)) %>% 
  #plots from Veg_bank seem to have a mix of feet and meter in Altitude
  mutate(`Altitude (m)`=ifelse(`GIVD ID`=="NA-US-002", NA, `Altitude (m)`)) %>%  
  mutate(`Slope (°)`=ifelse(`Slope (°)`<0, NA, `Slope (°)`)) %>%  
  mutate_at(.vars=vars(starts_with("Height") & contains("shrubs")),  
            ~ifelse(.>=10|.<0, NA, .)) %>% 
  mutate(`Relevé area (m²)`=ifelse(`Relevé area (m²)`<0, NA, `Relevé area (m²)`)) %>% 
  mutate(`Date of recording`=ifelse(`Date of recording`> as.Date('2016-01-01'), NA, `Date of recording`)) %>% 
  # Rename fields
  dplyr::select(
    #metadata + location
    PlotObservationID,
    GIVD_ID = "GIVD ID",
    Dataset,
    Continent = CONTINENT,
    Country,
    Biome,
    Date = "Date of recording",
    Latitude,
    Longitude,
    Location_uncertainty = "Location uncertainty (m)", #POINT_X, POINT_Y,
    #sampling design
    Releve_area = "Relevé area (m²)", 
    Herbs_identified = "Herbs identified (y/n)", #Mosses_identified="Mosses identified (y/n)", "Lichens identified (y/n)", 
    Plant_recorded = "Plants recorded",
    #topography
    Altitude = "Altitude (m)", 
    Aspect = "Aspect (°)", 
    Slope = "Slope (°)",
    #vegetation type
    is_forest = "is.forest",
    is_nonforest = "is.non.forest", 
    ESY, 
    Naturalness, 
    Forest,
    Shrubland, 
    Grassland, 
    Sparse_vegetation = "Sparse.vegetation", 
    Wetland,
    #vegetation structure
    Cover_total = "Cover total (%)", 
    Cover_tree_layer = "Cover tree layer (%)",
    Cover_shrub_layer = "Cover shrub layer (%)",
    Cover_herb_layer = "Cover herb layer (%)", 
    Cover_moss_layer = "Cover moss layer (%)", 
    Cover_lichen_layer ="Cover lichen layer (%)",
    Cover_algae_layer = "Cover algae layer (%)", 
    Cover_litter_layer = "Cover litter layer (%)", 
    Cover_bare_rocks = "Cover bare rock (%)",
    Cover_cryptogams = "Cover cryptogams (%)", 
    Cover_bare_soil = "Cover bare soil (%)", 
    Height_trees_highest = "Height (highest) trees (m)",
    Height_trees_lowest = "Height lowest trees (m)", 
    Height_shrubs_highest = "Height (highest) shrubs (m)", 
    Height_shrubs_lowest = "Height lowest shrubs (m)",
    Height_herbs_average = "Aver. height (high) herbs (cm)", 
    Height_herbs_lowest = "Aver. height lowest herbs (cm)", 
    Height_herbs_highest = "Maximum height herbs (cm)")
```


### DT Table

Complement taxon group using info from sPlot 3.0 and cross-matching congeneric species
```{r, warning=F}
DT.oa <- DT2 %>% 
  filter(PlotObservationID %in% unique(header.oa$PlotObservationID))

#load Backbonve sPlot 3.0
load("/data/sPlot/releases/sPlot3.0/Backbone3.0.RData")

## Assign genera to taxon group
taxon.groups <- DT.oa %>% 
  as.tbl() %>% 
  distinct(species) %>% 
  mutate(species2=species) %>% 
  separate(species2, into=c("Genus"), sep=" ") %>% 
  distinct(species, Genus) %>% 
  left_join(Backbone %>% 
              distinct(Name_short, `Taxon group`) %>% 
              rename(species=Name_short, 
                     Taxon.group=`Taxon group`) %>% 
              separate(species, into=c("Genus"), sep=" ") %>% 
              mutate(Taxon.group=as.character(Taxon.group)) %>% 
              mutate(Taxon.group=ifelse(Taxon.group=="Unknown", NA, Taxon.group)) %>% 
              distinct(Genus, .keep_all=T), 
            by="Genus") %>% 
  distinct(species, .keep_all = T) %>% 
  dplyr::select(-Genus)
  
DT2.oa <- DT.oa %>% 
  as.tbl() %>% 
  mutate(Taxon.group=as.character(Taxon.group)) %>% 
  mutate(Taxon.group=ifelse(Taxon.group=="Unknown", NA, Taxon.group)) %>% 
  mutate(species2=species) %>% 
  separate(species2, into=c("Genus"), sep=" ") %>% 
  ## cross complement internally, based on Genus
  left_join({.} %>% 
              filter(!is.na(Taxon.group)) %>% 
              #there may be conflict in attribution of specific genera to taxon group. Use majority vote
              group_by(Genus, Taxon.group) %>% 
              summarize(n=n(), .groups = 'drop') %>% 
              arrange(Genus, desc(n)) %>% 
              slice(1) %>% 
              dplyr::select(-n), 
            by="Genus") %>% 
  mutate(Taxon.group=coalesce(Taxon.group.x, Taxon.group.y)) %>% 
  dplyr::select(-Taxon.group.x, -Taxon.group.y) %>% 
  # attach taxon group info from Backbone 3.0
  left_join(taxon.groups, by="species") %>% 
  mutate(Taxon.group=coalesce(Taxon.group.x, Taxon.group.y)) %>% 
  dplyr::select(-Taxon.group.x, -Taxon.group.y, -Genus)

dim(DT2.oa)
table(DT2.oa$Taxon.group, exclude = NULL)
```

Clean up `DT2.oa` from all non vascular plant records and recalculate relative covers.

```{r}
DT2.oa <- DT2.oa %>% 
  filter(Taxon.group != c("Alga", "Lichen", "Moss")) %>% 
  left_join({.} %>%
              group_by(PlotObservationID) %>% 
              summarize(tot.cover=sum(Relative.cover), .groups = 'drop'), 
            by=c("PlotObservationID")) %>% 
  mutate(Relative.cover=Relative.cover/tot.cover) %>% 
  dplyr::select(-tot.cover)
```
The field `Layer` is always zero. Delete.
```{r}
DT2.oa <- DT2.oa %>% 
  dplyr::select(-Layer)
```

#### Abundance and cover data

Species abundance information varies across datasets and plots. While for the large majority of plots abundance values are returned as percentage cover, there is a subset where abundance is returned with different scales. These are marked in the column `Cover code` as follows:
\newline \newline
*x_BA* - Basal Area  
*x_IC* - Individual count  
*x_SC* - Stem count  
*x_IV* - Relative Importance  
*x_PF* - Presence Frequency  
*x* - Presence absence  
\newline \newline
Still, it's not really intuitive that in case `Cover code` belongs to one of the classes above, then the actual abundance value is stored in the `x_` column. This stems from the way this data is stored in `TURBOVEG`.  
To make the cover data more user friendly, I simplify the way cover is stored, so that there are only two columns:  
`Ab_scale` - to report the type of scale used  
`Abundance` - to coalesce the cover\\abundance values previously in the columns `Cover %` and `x_`.  
\\newline

This information is stored in a working copy of the DT table, before standardization to relative cover. Import it and filter only plots in open-access selection.

```{r}
DTraw <- read_delim(
  "/data/sPlot2.0/sPlot_2015_07_29_species.csv",
  delim = "\t",
  col_types = cols(
    PlotObservationID = col_double(),
    Taxonomy = col_character(),
    `Taxon group` = col_character(),
    `Taxon group ID` = col_double(),
    `Turboveg2 concept` = col_character(),
    `Matched concept` = col_character(),
    Match = col_double(),
    `Original taxon concept` = col_character(),
    Layer = col_double(),
    `Cover %` = col_double(),
    `Cover code` = col_character(),
    x_ = col_character()
  )) %>% 
  filter(PlotObservationID %in% header.oa$PlotObservationID)
```

Create `Ab_scale` field
```{r}
DTraw <- DTraw %>% 
  mutate(Ab_scale = ifelse(`Cover code` %in% 
                             c("x_BA", "x_IC", "x_SC", "x_IV", "x_PF", "x") & !is.na(x_), 
                           `Cover code`, 
                           "CoverPerc"))  
#mark pa plots
DTraw <- DTraw %>% 
  mutate(Ab_scale=replace(Ab_scale,
                    list=`Cover code`=="x" & `Cover %`==0,
                    values="pa"))
```

Fix some errors. There are some plots where all species have zeros in the field `Cover %`. Some of them are marked as p\\a (`Cover code=="x"`), but other not. Consider all this plots as presence\\absence. Most of them come from `USA_CVS` and `USA_VegBank`. 
```{r}
allzeroes <- DTraw %>% 
  filter(Ab_scale=="CoverPerc") %>% 
  group_by(PlotObservationID) %>% 
  summarize(allzero=all(`Cover %`==0), .groups = 'drop' ) %>% 
  filter(allzero==T) %>% 
  pull(PlotObservationID)
DTraw <- DTraw %>%
  mutate(`Cover code` = replace(`Cover code`,
    list = (PlotObservationID %in% allzeroes),
    values = "x")) %>%
  mutate(`Ab_scale` = replace(`Ab_scale`,
    list = (PlotObservationID %in% allzeroes),
    values = "pa"))
```
For p\\a plots, replace the field `Cover %` with NA, and assign 1 to the field `x_`. 
```{r}
DTraw <- DTraw %>% 
 mutate(x_=replace(x_,
                    list=Ab_scale=="pa",
                    values=1)) %>% 
  mutate(`Cover %`=replace(`Cover %`,
                    list=Ab_scale=="pa",
                    values=NA))
```

There are also some plots having different cover scales. They are not many, and are mostly in Brazil.  
Find these plots first:
```{r}
mixed <- DTraw %>% 
  distinct(PlotObservationID, Ab_scale) %>% 
  group_by(PlotObservationID) %>% 
  summarize(n=n(), .groups = 'drop') %>% 
  filter(n>1) %>% 
  pull(PlotObservationID) %>% 
  unique()
length(mixed)
```
Most of these plots are a mixture of trees, being measured based on Basal area, and herbs, for which only p\\a was recorded. Transform the `Cover %` of p\\a species to an arbitrary small number, i.e., 1.  
Note that the field `Abundance` is created only here.
```{r}
DTraw <- DTraw %>% 
  mutate(Ab_scale=replace(Ab_scale, 
                           list=(PlotObservationID %in% mixed & 
                                   Ab_scale=="CoverPerc"), 
                           values="pa")) %>%
  mutate(`Cover %`=replace(`Cover %`, 
                           list=PlotObservationID %in% mixed,
                           values=NA)) %>% 
  mutate(x_=replace(x_,  list=Ab_scale=="pa", values=1)) %>% 
  #Create additional field Abundance to avoid overwriting original data
  mutate(Abundance =ifelse(Ab_scale %in% c("x_BA", "x_IC", "x_SC", "x_IV", "x_RF", "pa"), 
                          x_, `Cover %`)) %>% 
  mutate(Abundance=as.numeric(Abundance))
```

Double check and summarize `Ab_scales`
```{r}
scale_check <- DTraw %>% 
  distinct(PlotObservationID, Layer, Ab_scale) %>% 
  group_by(PlotObservationID) %>% 
  summarise(Ab_scale_combined=ifelse(length(unique(Ab_scale))==1, 
                                     unique(Ab_scale), 
                                     "Multiple_scales"), 
            .groups = 'drop')

nrow(scale_check)== length(unique(DTraw$PlotObservationID))
table(scale_check$Ab_scale_combined, exclude=NULL)
```
Attach fields `Ab_scale` and `Abundance` to DT2.oa. Rename columns.

```{r}
DT2.oa <- DT2.oa %>% 
  left_join(DTraw %>% 
              dplyr::select(PlotObservationID, Matched.concept=`Matched concept`, Ab_scale, Abundance), 
            by=c("PlotObservationID", "Matched.concept")) %>% 
  dplyr::select(PlotObservationID, Species=species, Original_species=Matched.concept, 
                Taxon_group=Taxon.group, Original_abundance=Abundance, Abundance_scale=Ab_scale, Relative_cover=Relative.cover)
```


```{r, echo=F}
knitr::kable(DT2.oa %>%
               filter(PlotObservationID %in% sample(header.oa$PlotObservationID, 3)),
             caption="Example of DT2.oa [3 randomly selected plots shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```
#### Update individual datasets
There are two datasets whose species names need to be updated before releasing OA.


#### AF-CD-001 - Congo
Import updated data and convert to long format
```{r, message=F}
congo.new.raw <- read_csv("_data/Update_Congo/Kearsley_Yangambi_sPlot_subplots_v2.csv")

congo.new <- congo.new.raw %>% 
  mutate(BA=pi* ((`DBH (cm)`/100/2)^2)) %>% 
  group_by(Site, Species) %>% 
  summarize(BA=sum(BA), .groups="drop") %>% 
  bind_rows({.} %>% 
              separate(Site, into=c("Site", "Subplot", sep=" - ")) %>% 
              group_by(Site, Species) %>% 
              summarize(BA=sum(BA))) %>% 
  distinct() %>% 
  mutate(Site2=Site) %>% 
  separate(Site2, into=c("Plot", "Subplot")) %>% 
  mutate(Area=ifelse(!is.na(Subplot), 625, 10000)) %>% 
  mutate(BA.ha=BA/Area*10000) %>% 
  arrange(Site, Species) %>% 
  dplyr::select(Site, Plot, Subplot, Species, BA, BA.ha)
head(congo.new)
```
Assign PlotObservationID to plot codes
```{r}
### Data from Stephan 
header.TV <- read_delim(file = "_data/sPlot-2.1_header.csv", delim = "\t", 
                        col_types = cols(PlotObservationID = col_double(),
                                        PlotID = col_double(),
                                        `TV2 relevé number` = col_double(),
                                        `Original nr in database` = col_character(),
                                        ORIGDB_NR = col_character(),
                                        ORIGDB_NR_1 = col_character(),
                                        ORIG_REL_N = col_character(),
                                        Longitude = col_double(),
                                        Latitude = col_double(),
                                        `Location uncertainty (m)` = col_double(),
                                        Dataset = col_character()))

header.sel.TV <- header.oa %>%
  dplyr::select(PlotObservationID, GIVD_ID) %>% 
  left_join(header.TV %>% 
              dplyr::select(PlotObservationID, `Original nr in database`),
            by="PlotObservationID")

congo.new <- congo.new %>% 
  inner_join(header.sel.TV, by=c("Site"="Original nr in database")) %>% 
  relocate(PlotObservationID, .before=Site)
```

Correct species names based on sPlot v2.1 Backbone
```{r}
## load backbone
load("/data/sPlot/releases/sPlot2.1/backbone.splot2.1.try3.is.vascular.Rdata")

## join names from backbone to congo.new
congo.new <- congo.new %>% 
  mutate(Species=str_replace(Species, pattern=" sp.$", replacement="")) %>% 
  left_join(backbone.splot2.1.try3 %>% 
              dplyr::select(Species=Name_submitted, New_species=name.short.correct) %>% 
              distinct(), 
            by="Species") %>% 
  ##manually correct two mistakes in Backbone
  mutate(New_species=ifelse(New_species %in% c("Canarium schweinfurtii", "Prioria balsaminfera"),
                            Species, 
                            New_species)) %>% 
  ## delete unidentified species 
  filter(Species != "unknown")

## check species names to change, based on the backbone
congo.new %>% 
  filter(Species != New_species) %>% 
  distinct(Species, .keep_all=T)

### get all unmatched species and run through TPL
# tocheck <- congo.new %>% 
#  filter(is.na(New_species)) %>% 
#  pull(Species) %>% 
#  unique()
#
# library(Taxonstand)
# checked <- TPL(tocheck)
# checked2 <- data.frame(old_species=tocheck) %>% 
#   bind_cols(checked %>% 
#               dplyr::select(New.Genus, New.Species)) %>% 
#   replace_na(list(New.Genus="", New.Species="")) %>% 
#   unite(New.Genus, New.Species, col=new_species, sep=" ") %>% 
#   mutate(new_species=str_replace(new_species, pattern=" *$", replacement=""))
# ## all unmatched names are valid names, based on TPL2
# print(checked2, n=12)

## assign unmatched old names to new names
congo.new <- congo.new %>% 
  mutate(New_species=ifelse(is.na(New_species), 
                            Species, New_species))
```

Format `congo.new` to match `DT2.oa`
```{r}
congo.out <- congo.new %>%
  rename(Original_abundance = BA.ha, 
         Original_species=Species) %>% 
  rename(Species=New_species) %>%
  mutate(Taxon_group = "Vascular plant") %>%
  mutate(Abundance_scale = "x_BA") %>%
  left_join({.} %>%
    group_by(PlotObservationID) %>%
    summarize(Tot_abundance = sum(Original_abundance),
      .groups = "drop"),
    by = "PlotObservationID") %>%
  mutate(Relative_cover = Original_abundance / Tot_abundance) %>% 
  dplyr::select(all_of(colnames(DT2.oa)))

## compare a random plot before and after replacement
plotsel <- sample(unique(congo.new$PlotObservationID), 1)
DT2.oa %>% filter(PlotObservationID==plotsel) %>% print(n=15)
congo.out %>% filter(PlotObservationID==plotsel) %>% print(n=15)
```
Replace entries in `DT2.oa`
```{r}
dim(DT2.oa)
DT2.oa <- DT2.oa %>% 
  filter(!PlotObservationID %in% (congo.out %>% 
                                   pull(PlotObservationID) %>% 
                                   unique())) %>% 
  bind_rows(congo.out) %>% 
  arrange(PlotObservationID, Species)
dim(DT2.oa)
```


#### Correct known issues
```{r}
DT2.oa <- DT2.oa %>%
  mutate(Species = ifelse(Species == "lachenalii subsp.",
                          "Hieracium lachenalii",
                          Species)) %>%
  mutate(Species = ifelse(Species == "virgaurea subsp.",
                          "Solidago virgaurea",
                          Species)) %>%
  mutate(Species = ifelse(Species == "murorum subsp.",
                          "Hieracium murorum",
                          Species)) %>%
  mutate(Species = ifelse(Species == "dubius subsp.",
                          "Tragopogon dubius",
                          Species))
```




### CWM data

Load species level gap-filled trait data
```{r}
load("/data/sPlot2.0/TRY.all.mean.sd.3.by.genus.species.Rdata")
TRY <- TRY.all.mean.sd.3.by.genus.species
```

Merge species data table with traits, and calculate species coverage for each plot, both based on relative cover, and number of species having trait info.
```{r}
CWM.oa0 <- DT2.oa %>%
  as.tbl() %>%
  dplyr::select(PlotObservationID, Species, Relative_cover) %>%
  left_join(TRY %>%
              dplyr::rename(Species=StandSpeciesName) %>%
              dplyr::select(Species, LeafArea.mean:Wood.vessel.length.mean), 
            by="Species") %>% 
  rename_at(.vars=vars(ends_with(".mean")), 
            .funs=~gsub(pattern=".mean", replacement="", x=.))

# Calculate coverage for each trait in each plot
CWM.oa2 <- CWM.oa0 %>%
  mutate_at(.vars = vars(LeafArea), 
            .funs = list(~if_else(is.na(.),0,1) * Relative_cover)) %>%
  group_by(PlotObservationID) %>%
  summarize(TraitCoverage_cover=sum(LeafArea, na.rm=T),
            Species_richness=n(),
            TraitCoverage_pa=mean(LeafArea>0), 
            .groups = 'drop')
```

Calculate CWM and CWV for each trait in each plot
```{r, cache=T}
# Ancillary function to calculate CWV
variance2.fun <- function(trait, abu){
  res <- as.double(NA)
  #nam <- nam[!is.na(trait)]
  abu <- abu[!is.na(trait)]
  trait <- trait[!is.na(trait)]
  abu <- abu/sum(abu)
  if (length(trait)>1){
    # you need more than 1 observation to calculate
    # skewness and kurtosis
    # for calculation see 
    # http://r.789695.n4.nabble.com/Weighted-skewness-and-curtosis-td4709956.html
    m.trait <- weighted.mean(trait,abu)
    res <- sum(abu*(trait-m.trait)^2)
  }
  res
}

CWM.oa1 <- CWM.oa0 %>%
  group_by(PlotObservationID) %>%
  summarize_at(.vars= vars(LeafArea:Wood.vessel.length),
               .funs = list(CWM=~weighted.mean(., Relative_cover, na.rm=T), 
                            CWV=~variance2.fun(., Relative_cover)))

```
Assemble output
```{r}  
CWM.oa <- header.oa %>% 
  dplyr::select(PlotObservationID) %>% 
  left_join(CWM.oa2, by="PlotObservationID") %>% 
  left_join(CWM.oa1, by="PlotObservationID")

dim(CWM.oa)
```

Rename fields to follow convention
```{r}
CWM.oa <- CWM.oa %>% 
  rename_all(.funs=~gsub('\\.', '_', x = .)) %>% 
  colnames()
```


## Figures and Tables
### Geographic distribution of plots

Template of Global map
```{r, cache=T, results="hide", warning=F, message=F}
#download data from rnaturalearth package
countries <- ne_countries(returnclass = "sf") %>% 
  st_transform(crs = "+proj=eck4") %>% 
  st_geometry()
graticules <- ne_download(type = "graticules_15", category = "physical",
                          returnclass = "sf") %>% 
  st_transform(crs = "+proj=eck4") %>% 
  st_geometry()
bb <- ne_download(type = "wgs84_bounding_box", category = "physical",
                  returnclass = "sf") %>% 
  st_transform(crs = "+proj=eck4") %>% 
  st_geometry()

# create ggplot template of the world map
w3a <- ggplot() +
  geom_sf(data = bb, col = "grey20", fill = "white") +
  geom_sf(data = graticules, col = "grey20", lwd = 0.1) +
  geom_sf(data = countries, fill = "grey90", col = NA, lwd = 0.3) +
  coord_sf(crs = "+proj=eck4") +
  theme_minimal() +
  theme(axis.text = element_blank(), 
        legend.title=element_text(size=12), 
        legend.text=element_text(size=12),
        legend.background = element_rect(size=0.1, linetype="solid", colour = 1), 
        legend.key.height = unit(1.1, "cm"), 
        legend.key.width = unit(1.1, "cm")) +
  scale_fill_viridis()
```

Data Preparation for spatial plotting
```{r, cache=T, results="hide", warning=F, message=F}
header.sf <- SpatialPointsDataFrame(coords= header.oa %>% 
                                      select(Longitude, Latitude), 
                                    proj4string = CRS("+init=epsg:4326"), 
                                    data=data.frame(PlotObservationID=header.oa$PlotObservationID, 
                                                    Dataset=header.oa$Dataset)) %>% 
  st_as_sf() %>% 
  st_transform(crs = "+proj=eck4")
```

Map of plot distribution - Version 1 - Coloured point.  
Each colour represents a database. Please note there are not enough colours in the palette to represent all 103 datasets
```{r, fig.width=8, fig.height=6, fig.align="center", warning=F, message=F}
w3a + 
  geom_sf(data=header.sf, aes(color=Dataset), pch="+", size=1, alpha=0.8) + # aes(col=Dataset),
  geom_sf(data = countries, col = "grey10", fill=NA, lwd = 0.3) + 
  theme(legend.position = "none")
```

Version 2  - hexagons
```{r, fig.width=8, fig.height=6, fig.align="center", message=F}
header2 <- header.oa %>% 
  select(PlotObservationID, Latitude, Longitude) %>% 
  filter(!(abs(Longitude) >171 & abs(Latitude>70)))
dggs <- dgconstruct(spacing=300, metric=T, resround='down')

#Get the corresponding grid cells for each plot
header2$cell <- dgGEO_to_SEQNUM(dggs, header2$Longitude, header2$Latitude)$seqnum

#Calculate number of plots for each cell
header.dggs   <- header2 %>% 
  group_by(cell) %>% 
  summarise(value.out=log(n(), 10))

#Get the grid cell boundaries for cells 
grid   <- dgcellstogrid(dggs, header.dggs$cell, frame=F) %>%
  st_as_sf() %>% 
  mutate(cell = header.dggs$cell) %>% 
  mutate(value.out=header.dggs$value.out) %>% 
  st_transform("+proj=eck4") %>% 
  st_wrap_dateline(options = c("WRAPDATELINE=YES"))

## plotting
w3a + 
    geom_sf(data=grid, aes(fill=value.out),lwd=0, alpha=0.9)    +
    geom_sf(data = countries, col = "grey10", fill=NA, lwd = 0.3) + 
    scale_fill_viridis(
      name="# plots", breaks=0:5, labels = c("1", "10", "100",
                                             "1,000", "10,000", "100,000"), option="viridis" )

```

### Whittaker Biome Graph
Get climatic data
```{r}
load("/data/sPlot/releases/sPlot2.1/sPlot_header_chelsa_20161124.RData")
climate.oa <- climate %>% 
  filter(PlotID %in% header.oa$PlotObservationID) %>% 
  dplyr::select(-POINT_X, -POINT_Y) %>% 
  rename(PlotObservationID=PlotID)
```

```{r, fig.width=8, fig.height=5, fig.align="center", message=F}
whittaker_base_plot() +
  theme_classic() + 
  geom_point(data=climate.oa %>% 
                filter(bio12<4500 & bio01>-11), #filter out for plotting reasons 
              aes(x=bio01, y=bio12/10), 
             alpha=1/3, 
             cex=1/15)
```


### Summary tables
Table 1 - Database level information

```{r}
table1 <- databases %>% 
  filter(`Still in sPlot`==T, 
         Via!="Aggregator") %>% 
  dplyr::select(-Via, -`Still in sPlot`, -label) %>% 
  distinct() %>% 
  left_join(header.oa %>% 
              group_by(GIVD_ID) %>% 
              summarize(contributed_plots=n(), .groups = 'drop'), 
            by=c("GIVD ID"="GIVD_ID")) %>% 
  dplyr::select(`GIVD ID`,`DB_name GIVD`, Custodian, `Deputy custodian`, n_Plots, contributed_plots, Citation) %>% 
  filter(!is.na(contributed_plots))

write_csv(table1, "_output/Table1_Databases.csv")
```

```{r, echo=F}
knitr::kable(table1%>% 
               slice(1:20),
             caption="Table 1 - Database level information [only first 20 rows shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```


Table 2 - Metadata and environmental data included in header  

Create table 2 
```{r}
table2 <- header.oa %>% 
summarize_at(.vars=vars(!starts_with("PlotObservationID")),
            .funs = list(xxxNo.records=~sum(!is.na(.)),
               xxxType.of.variable=~class(.), 
               xxxLevels=~(ifelse(is.numeric(.)|lubridate::is.Date(.), 
                                  paste(range(., na.rm=T), collapse=" - "),
                                  ifelse(is.factor(.), 
                                         paste(levels(.), collapse=", "),
                                         ifelse(is.logical(.),
                                                paste(names(table(.)), "=", 
                                                      table(.), collapse="; "),
                                                NA)))))) %>% 
  gather(key="Variable") %>% 
  separate(Variable, into = c("Variable", "feature"), sep="_xxx") %>% 
  spread(key=feature, value = value) %>% 
  rename(`Range/Levels`=Levels) %>% 
  mutate(Variable=factor(Variable, levels=colnames(header.oa))) %>% 
  arrange(Variable) 

write_csv(table2, "_output/Table2_header.csv")
```

```{r, echo=F}
knitr::kable(table2,
             caption="Table 2 - Variables in header") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```
## Save Ouput
```{r}
save(DT2.oa, header.oa, CWM.oa, file = "_output/sPlot_OPEN.RData")
```
### Sink tables for Manubot
```{r}
out.file <- "_output/91.ManubotTables.md"
readr::write_lines("## Supplementary Material {.page_break_before}\n", file = out.file)
readr::write_lines("Table: List of databases contributing to the open access dataset extracted from the sPlot database. Databases are ordered based on their ID in the Global Index of Vegetation Databases (GVID ID). {#tbl:Table1 tag='11'}\n", file = out.file, append=T)
readr::write_lines("\n \n", file = out.file, append=T)
readr::write_lines(kable(table1, format = "markdown"), file = out.file, append=T)
readr::write_lines("\n \n \n", file = out.file, append=T)
readr::write_lines("Table: Description of the variables contained in the ‘header’ matrix, together with their range (if numeric) or possible levels (if nominal or boolean). Variable type can be c - character (i.e. text), f - factor (i.e. qualitative or ordinal variable), i - integer (e.g. binomial), n - numeric (i.e., double) or l - logical (i.e., boolean). {#tbl:Table2 tag='12'}\n", file = out.file, append=T)
readr::write_lines(kable(table2, format = "markdown"), file = out.file, append=T)
```
### Create list of coauthors
```{r echo = T, results = 'hide', message=F}
library(stringr)
allroles <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/roles.csv")
allaffiliations <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/Affiliations.csv") %>% 
  left_join(allroles %>% 
                dplyr::select(Name,Surname), 
              by="Name")

first <- allaffiliations %>% 
  filter(Name %in% c("Francesco Maria Sabatini", "Jonathan Lenoir")) %>% 
  arrange(Name)
##third author still to code Tarek Habab
custodians <- unique(table1$Custodian)
core <- allaffiliations %>% 
  filter(Name %in% (allroles %>%
           filter(`Core team` == T) %>%
           filter(!Surname %in% c("Bruelheide", "Sabatini", "Lenoir")) %>%
           pull(Name))) %>% 
  arrange(Surname) 
last <- allaffiliations %>% 
  filter(Name=="Helge Bruelheide")

affiliations <- first %>% 
  bind_rows(core) %>% 
  bind_rows(allaffiliations %>% 
    filter(Name %in% custodians) %>% 
    filter(!Name %in% core$Name) %>% 
    filter(!Name %in% first$Name) %>% 
    filter(!Name %in% last$Name) %>% 
    arrange(Surname)) %>%  
  bind_rows(last) %>% 
  dplyr:::select(name=Name, email=`E-Mail`, orcid=ORCID, everything(), -Surname, -`Second E-Mail`) %>% 
    replace_na(list(`Department/Institute/Faculty`="", Street="", `Postal code`="", Town="",   Country="" )) %>% 
  unite(`University/Institution`, `Department/Institute/Faculty`, Street:Country, sep = ", ", col="affiliations", remove=T) %>% 
  mutate(affiliations=str_replace_all(string = affiliations, pattern=", , ", replacement = ", "))


## function to format name, orcid, email and affiliation info into the metadata.yaml standard for manubot
create.yaml <- function(x, file.output){
  tmp <- affiliations %>%
    mutate(github="") %>% 
    filter(name==x) %>% 
    pivot_longer(!Sequence_affiliations, names_to = "tag") %>%
    arrange(Sequence_affiliations) %>% 
    dplyr::select(-Sequence_affiliations) %>% 
    mutate(tag=factor(tag, levels=c("github", "name", "orcid", "email", "affiliations"))) %>% 
    distinct() %>% 
    bind_rows(data.frame(tag="affiliations", 
                         value=paste0("\n      - ", 
                                      paste({.} %>% 
                                              filter(tag=="affiliations") %>% 
                                              pull(value),
                                            collapse="\n      - ")))) %>% 
    group_by(tag) %>% 
    slice(n()) %>% 
    ungroup() %>% 
    mutate(tag=as.character(tag)) %>% 
    mutate(tag=ifelse(tag=="github", "  - github", paste0("    ", tag))) %>% 
    filter(!is.na(value)) %>%
    unite(tag:value,
          sep = ": ",
          col = "newtag",
          remove = T) %>% 
    mutate(newtag=str_remove(newtag, pattern = '"')) %>% 
    mutate(newtag=str_remove(newtag, pattern = '"')) %>% 
    mutate(newtag=str_replace_all(string = newtag, pattern=", , ", replacement = ", ")) %>% 
    mutate(newtag=str_replace_all(string = newtag, pattern=", , ", replacement = ", "))
    write_lines(tmp[[1]], file = file.output, append=T) 
}

affi.out <- "_output/affiliations_yaml.txt" #create empty affiliation file
##populate yaml file with affiliaiton info
write_lines("", file = affi.out)
lapply(affiliations %>% 
         dplyr::select(name) %>% 
         distinct() %>% 
         pull(name), create.yaml, affi.out)
```


## SessionInfo
```{r}
sessionInfo()
```

