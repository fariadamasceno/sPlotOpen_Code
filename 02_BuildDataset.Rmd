---
title: "Project#02 - Build Dataset"
author: "Francesco Maria Sabatini"
date: "4/28/2020"
output:
  html_document:
    toc: true
    theme: united
---

<center>
  ![](https://www.idiv.de/fileadmin/content/Files_sDiv/sDiv_Workshops_Photos_Docs/sDiv_WS_Documents_sPlot/splot-long-rgb.png "sPlot Logo")
</center>
  
    
      
        
**Timestamp:** `r date()`  
**Drafted:** Francesco Maria Sabatini  
**Revised:**  
**Version:** 1.0
  
This report describes how data from the sPlot database have been extracted to build an environmentally-balanced subset. Resampling of plots in the environmental space follows [Bruelheide et al. 2018 NEE](https://www.nature.com/articles/s41559-018-0699-8), and is done elsewhere.  
All data custodians were contacted individually and asked for permission to make a chunk of their data  open-access. Here I only reported the collated answers. 
  
```{r results="hide", message=F, warning=F}
library(tidyverse)
### Conflict with new tibble 3.0.0 - I had to fall back on previous versions of some of the tidyverse packages
#library(devtools)
#install_version("tibble", version = "2.1.3")
#install_version("broom", version = "0.5.5")
#install_version("modelr", version = "0.1.6")
library(openxlsx)
library(bib2df)
library(knitr)
library(kableExtra)
library(viridis)
library(plotbiomes)

#library(raster)
library(sp)
library(sf)
library(rgdal)
library(rnaturalearth)
library(dggridR)
# library(rgeos)

#save temporary files
write("TMPDIR = /data/sPlot/users/Francesco/_tmp", file=file.path(Sys.getenv('TMPDIR'), '.Renviron'))
write("R_USER = /data/sPlot/users/Francesco/_tmp", file=file.path(Sys.getenv('R_USER'), '.Renviron'))
#rasterOptions(tmpdir="/data/sPlot/users/Francesco/_tmp")
```
# Import and clean data

Import and fix sPlot data. Import and attach database-level information and [GIVD](https://www.givd.info/) codes. 
```{r, cache=T, results="hide", message=F, warning=F}
load("/data/sPlot/releases/sPlot2.1/DT2_20161025.RData")
load("/data/sPlot/releases/sPlot2.1/sPlot_header_20161124.RData")
#fix header data
source("/data/sPlot/users/Francesco/_sPlot_Management/Fix.header.R")
header <- fix.header(header, exclude.sophy = F)
```
Import database level answers from custodians. This table reports whether the plots from a given dataset can be released open-access without condition (Yes); whether this is true only for a set of manually selected plots (Conditional); or cannot be used (No).
```{r}
answers <- openxlsx::read.xlsx("_management/resampling_answers.xlsx", sheet = 2)
answers <- answers %>% 
  mutate(`Yes/Conditional/No`=fct_recode(`Yes/Conditional/No`, No="NO", Yes="yes")) %>% 
  # Manually set some dataset to yes
  # Rasmus Revermann and Donald Walker's acceptance is conditional, 
  # but depends on conditions others than the selection of plot.
  mutate(`Yes/Conditional/No`=replace(`Yes/Conditional/No`, 
                                    list=GIVD.ID %in% c("NA-US-014","AF-00-009", 
                                                        "AF-00-006", "00-00-003"),  
                                    values="Yes"))

head(answers)
```

Import IDs of first choice plots, i.e. plots resampled in iteration 1. Load redundant list of plots selected in runs 1-3 of resampling (first choice + reserves), with plot-level specification from dataset custodians wheter a plot is usable (i.e., can be released OA) or not. 
```{r results="hide", message=F, warning=F}
# first choice plot IDs
sel1 <- readr::read_csv("_data/Resampled1.csv")$x

# First choice plots + reserves
usable.plots123 <- readr::read_csv("_output/header.sel.final.csv") %>% 
  mutate(first.choice=PlotObservationID %in% sel1) %>% 
  distinct()

#compute summary
summary.sel.final <- usable.plots123 %>% 
  group_by(`GIVD ID`, Dataset, Custodian, `Deputy custodian`) %>% 
  ### Summarize data at dataset level
  summarize(N.redundant=n(), 
            usable=sum(Usable=="Yes"), 
            not.usable=sum(Usable=="No"), 
            unknown=sum(Usable=="Unknown"), .groups = 'drop') %>% 
  ### total number of plots in a dataset
  left_join(header %>% 
              group_by(`GIVD ID`) %>% 
              summarize(n.tot.plot=n(), .groups = 'drop'),
            by="GIVD ID") %>% 
  ### number of first choice plots
  left_join(header %>% 
              filter(PlotObservationID %in% sel1) %>% 
              group_by(`GIVD ID`) %>% 
              summarize(n.sel.plot=n(), .groups = 'drop'),
            by="GIVD ID") %>% 
  mutate(share.perc=round(n.sel.plot/n.tot.plot*100),1) %>% 
  dplyr::select(`GIVD ID`:`Deputy custodian`, n.tot.plot:share.perc, N.redundant:unknown) 

#check how many first choice plots can be used, and how many need replacement
firstchoice <- usable.plots123 %>% 
  mutate(Usable=forcats::fct_recode(Usable, "No" = "Unknown")) %>% 
  group_by(first.choice, Usable) %>% 
  summarize(n=n(), .groups = 'drop')
```

```{r, echo=F}
knitr::kable(summary.sel.final %>% 
               rename(`Total # plots in DB (A)`=n.tot.plot, 
                      `First choice plots (B)`=n.sel.plot, 
                      `Percentage B/A`=share.perc, 
                      `# First choice + reserves (C)`=N.redundant, 
                      `# of plots in (C) usable`=usable,
                      `# of plots in (C) not_usable`=not.usable,
                      `# of plots in (C) no_info`=unknown), 
             
             caption="Summary of first choice and reserve plots per dataset, with aggregated info on how many plots can be used (i.e., release OA)") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```
Out of the `r length(sel1)` plots selected in the first run of the resampling, `r firstchoice %>% filter(first.choice==T & Usable =="Yes") %>% pull(n)` can be used. The remaining `r firstchoice %>% filter(first.choice==T & Usable =="No") %>% pull(n)` require to be replaced.

# Replace plots not usable with reserves
In those cases where we do not have permission to use a plot selected in resampling run #1 [first.choice], we replace it with a reserve belonging to the same cell in the PCA space grid. Reserves correspond to plots selected in resamplings runs #2 or #3, whose use was approved by the respective custodians. Additionally we considered as usable reserves ALL those plots belonging to datasets whose custodian gave us unconditional permission to use their data.  
PCA is calculated in the environmental space defined by the 30 climatic and soil variables used in Bruelheide et al. 2018 NEE.  

Load PCA data
```{r}
load("_data/plot_data.RData")
pca.grids <- plot_data %>% 
  filter(PlotObservationID %in% header$PlotObservationID) %>% 
  #attach GIVD codes 
  left_join(header %>% 
              distinct(`GIVD ID`,Dataset), 
            by="Dataset") %>% 
  dplyr::select(PlotObservationID,`GIVD ID`, Dataset, 
                cellID, pc1_val, pc2_val) %>% 
  as_tibble() %>% 
  #Attach info on first choice, reserve and usable plots
  mutate(first.choice=PlotObservationID %in% sel1) %>% 
  left_join(usable.plots123 %>% 
              dplyr::select(PlotObservationID, Usable) %>% 
              mutate(Usable=Usable=="Yes"), 
            by="PlotObservationID") %>% 
  mutate(reserve= (!PlotObservationID %in% sel1) & Usable==T) %>% 
  #Consider as usable reserves ALL those plots belonging to datasets whose custodian gave us
  # unconditional permission to use the data
  mutate(Usable=replace(Usable, 
                        list= (is.na(Usable) & 
                                 `GIVD ID` %in% (answers %>% 
                                     filter(`Yes/Conditional/No`=="Yes") %>% 
                                     pull(GIVD.ID))), 
                        values=T)) %>% 
  mutate(reserve=replace(reserve, 
                        list= (first.choice==F & 
                                 `GIVD ID` %in% (answers %>% 
                                     filter(`Yes/Conditional/No`=="Yes") %>% 
                                     pull(GIVD.ID))), 
                        values=T))

head(pca.grids %>% 
       dplyr::select(-pc1_val, -pc2_val))
```

For each non-usable first choice plot, find a reserve from the same grid cell in the PCA space.

```{r}
toreplace <- pca.grids %>% 
  filter(first.choice==T) %>% 
  filter(Usable==F) %>% 
  pull(PlotObservationID)

#number of first choice plots needing replacement
length(toreplace)

set.seed(9999)
selected.reserves <- pca.grids %>% 
  filter(reserve==T) %>% 
  #for each cell, calculate how many reserves would be needed, and how many reserves are available
  left_join(pca.grids %>% 
              group_by(cellID) %>% 
              summarize(n.first=sum(first.choice, na.rm=T),
                        n.first.usable=sum(first.choice*Usable, na.rm=T), 
                        reserve.available=sum(reserve, na.rm=T), .groups = 'drop') %>% 
              mutate(reserve.needed=n.first-n.first.usable),
            by=c("cellID")) %>% 
  filter(reserve.needed>0) %>% 
  # from each cell where >0 reserves are needed, sample randomly n usable reserves, 
  # where n is the minimun between the number of reserves needed and reserves available
  group_by(cellID) %>% 
  mutate(reserve.available=min(reserve.needed, reserve.available)) %>% 
  sample_n(reserve.available)
```

```{r, echo=F}
knitr::kable(selected.reserves %>% 
               dplyr::select(-pc1_val, -pc2_val) %>% 
               ungroup() %>%
               arrange(cellID) %>% 
               slice(1:20),
             caption="Example of selected reserves [first 20 rows shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```

By selecting plots within the same cell in the PCA grid, we can only replace `r nrow(selected.reserves)`, out of the `r length(toreplace)` non-usable first choice plots. 


# Build sPlot OA dataset
## Header
```{r}
header.oa <- header %>% 
  filter(PlotObservationID %in% (usable.plots123 %>%
                                   filter(first.choice==T) %>% 
                                   filter(Usable=="Yes") %>% 
                                     pull(PlotObservationID))) %>% 
  bind_rows(header %>% 
              filter(PlotObservationID %in% selected.reserves$PlotObservationID))
  
```
After merging first choice plots and the corresponding reserves, the database contains `r nrow(header.oa)` plots, stemming from `r header.oa %>% distinct("GIVD ID") %>% nrow()` databases.

Data preparation: adjust header data, select relevant variables, reformat variables into the right classes, correct macroscopic errors.
```{r, warning=F}
header.oa <- header.oa %>% 
    #reformat and rename
  mutate_at(.vars=vars(`Altitude (m)`, `Aspect (°)`, `Slope (°)`), 
            ~as.numeric(.)) %>% 
  mutate_at(.vars=vars(ESY), 
            ~as.character(.)) %>% 
  mutate_at(.vars=vars(Forest:Wetland), 
            ~as.logical(.)) %>% 
  mutate_at(.vars=vars(`Herbs identified (y/n)`, `Mosses identified (y/n)`, `Lichens identified (y/n)`),
            ~ifelse(.=="Y", T, F)) %>% 
  mutate(`Date of recording`=as.Date(`Date of recording`, "%d-%m-%Y") ) %>%
  mutate(CONTINENT=factor(CONTINENT, exclude = " ")) %>% 
  mutate(`Plants recorded`=factor(`Plants recorded`, exclude = "#N/A")) %>% 
  mutate(`Plants recorded`=forcats::fct_recode(`Plants recorded`, 
                                      "All vascular plants"="Complete vegetation",
                                      "All vascular plants"="all vascular plants", 
                                      "All vascular plants"="complete", 
                                      "All vascular plants"="Complete vegetation (including non-terricolous tax",
                                      "All vascular plants"="Vascular plants",
                                      "All woody plants"="Woody plants",
                                      "All woody plants"="All woody species",
                                      "Woody plants >= 10 cm dbh"= "trees>=10cm dbh",
                                      "Woody plants >= 10 cm dbh"= "Woody plants >= 10 cm dbh and domin",
                                      "All trees & dominant understory"="All trees & dominant shrubs",
                                      "Woody plants >= 5 cm dbh"="Woody plants >= 5 cm dbh & dominant",
                                      "Woody plants >= 1 cm dbh" = "Plants >= 1 cm dbh", 
                                      "Only dominant species"="Dominant vascular plants",
                                      "Woody plants >= 1 m height"="trees and shrubs >1 m height"
                                      )) %>% 
  ##correct mistakes
  mutate(`Altitude (m)`=ifelse(`Altitude (m)`< -100, NA, `Altitude (m)`)) %>% 
  #plots from Veg_bank seem to have a mix of feet and meter in Altitude
  mutate(`Altitude (m)`=ifelse(`GIVD ID`=="NA-US-002", NA, `Altitude (m)`)) %>%  
  mutate(`Slope (°)`=ifelse(`Slope (°)`<0, NA, `Slope (°)`)) %>%  
  mutate_at(.vars=vars(starts_with("Height") & contains("shrubs")),  
            ~ifelse(.>=10|.<0, NA, .)) %>% 
  mutate(`Relevé area (m²)`=ifelse(`Relevé area (m²)`<0, NA, `Relevé area (m²)`)) %>% 
  mutate(`Date of recording`=replace(`Date of recording`, 
                                     list=`Date of recording`> as.Date('2016-01-01'), 
                                     NA)) %>% 
  # Rename fields
  dplyr::select(
    #metadata + location
    PlotObservationID,
    GIVD_ID = "GIVD ID",
    Dataset,
    Continent = CONTINENT,
    Country,
    Biome,
    Date_of_recording = "Date of recording",
    Latitude,
    Longitude,
    Location_uncertainty = "Location uncertainty (m)", #POINT_X, POINT_Y,
    #sampling design
    Releve_area = "Relevé area (m²)", 
    Herbs_identified = "Herbs identified (y/n)", #Mosses_identified="Mosses identified (y/n)", "Lichens identified (y/n)", 
    Plant_recorded = "Plants recorded",
    #topography
    Elevation = "Altitude (m)", 
    Aspect = "Aspect (°)", 
    Slope = "Slope (°)",
    #vegetation type
    is_forest = "is.forest",
    is_nonforest = "is.non.forest", 
    ESY, 
    Naturalness, 
    Forest,
    Shrubland, 
    Grassland, 
    Sparse_vegetation = "Sparse.vegetation", 
    Wetland,
    #vegetation structure
    Cover_total = "Cover total (%)", 
    Cover_tree_layer = "Cover tree layer (%)",
    Cover_shrub_layer = "Cover shrub layer (%)",
    Cover_herb_layer = "Cover herb layer (%)", 
    Cover_moss_layer = "Cover moss layer (%)", 
    Cover_lichen_layer ="Cover lichen layer (%)",
    Cover_algae_layer = "Cover algae layer (%)", 
    Cover_litter_layer = "Cover litter layer (%)", 
    Cover_bare_rocks = "Cover bare rock (%)",
    Cover_cryptogams = "Cover cryptogams (%)", 
    Cover_bare_soil = "Cover bare soil (%)", 
    Height_trees_highest = "Height (highest) trees (m)",
    Height_trees_lowest = "Height lowest trees (m)", 
    Height_shrubs_highest = "Height (highest) shrubs (m)", 
    Height_shrubs_lowest = "Height lowest shrubs (m)",
    Height_herbs_average = "Aver. height (high) herbs (cm)", 
    Height_herbs_lowest = "Aver. height lowest herbs (cm)", 
    Height_herbs_highest = "Maximum height herbs (cm)")
```


The location of some RAINFOR plots is sensitive. I reduce the precision of their spatial coordinates
```{r}
header.oa <- header.oa %>% 
  mutate(Latitude=ifelse(GIVD_ID=="00-00-001", 
                         round(Latitude, 2), 
                         Latitude)) %>% 
  mutate(Longitude=ifelse(GIVD_ID=="00-00-001", 
                         round(Longitude, 2), 
                         Longitude)) %>% 
  mutate(Location_uncertainty=ifelse(GIVD_ID=="00-00-001", 
                         1000, 
                         Location_uncertainty))
           
```

### Formations
For those plots being classified based on the EUNIS codes, we used a cross-link table to use EUNIS to  assign vegetation types and naturalness, but only when these columns are empty. 
```{r}
eunis.key <- xlsx::read.xlsx("/data/sPlot/users/Francesco/sPlot3/_input/EUNIS_WFT.xlsx", 
                       sheetIndex = "Sheet1", endRow = 246) %>% 
  dplyr::select(EUNIS_code, NATURALNESS:SPARSE_VEG) %>% 
  mutate(EUNIS_code=as.character(EUNIS_code)) %>% 
  rename(ESY=EUNIS_code, 
         Naturalness=NATURALNESS, 
         Forest=FOREST,
         Shrubland=SCRUBLAND,
         Grassland=GRASSLAND,
         Wetland=WETLAND,
         Sparse_vegetation=SPARSE_VEG)#,

header.oa <- header.oa %>% # header.backup %>% 
  mutate(ESY=as.character(ESY)) %>% 
  #mutate(ESY=ifelse(ESY=="?", NA, ESY)) %>% 
  # Systematically assign some databases to forest
  mutate(Forest=ifelse(Dataset %in% 
                         c("Turkey Oak_Forest Database", 
                           "Turkey Forest Database", 
                           "Chile_forest", "Ethiopia"), 
                       T, Forest)) %>% 
  #fill up with F those rows where at least one column on formation is assigned
  rowwise() %>% 
  mutate(Any=any(Forest, Shrubland, Grassland, Wetland, Sparse_vegetation)) %>% 
  mutate(Forest=ifelse( (is.na(Forest) & Any), F, Forest))  %>%
  mutate(Shrubland=ifelse( (is.na(Shrubland) & Any), F, Shrubland))  %>% 
  mutate(Grassland=ifelse( (is.na(Grassland) & Any), F, Grassland))  %>% 
  mutate(Wetland=ifelse( (is.na(Wetland) & Any), F, Wetland))  %>% 
  mutate(Sparse_vegetation=ifelse( (is.na(Sparse_vegetation) & Any), F, Sparse_vegetation))  %>%
  ungroup() %>% 
  dplyr::select(-Any) %>%
  ##join and coalesce with eunis.key
  left_join(eunis.key %>% 
              distinct(), by = "ESY") %>% 
    mutate(
        Forest = dplyr:::coalesce(Forest.x, Forest.y), 
        Shrubland = coalesce(Shrubland.x, Shrubland.y),
        Grassland = coalesce(Grassland.x, Grassland.y),
        Wetland = coalesce(Wetland.x, Wetland.y),
        Sparse_vegetation = coalesce(Sparse_vegetation.x, Sparse_vegetation.y),
        Naturalness = coalesce(Naturalness.x, Naturalness.y)
    ) %>% 
  dplyr::select(-ends_with(".x"), -ends_with(".y")) %>% 
  #transform naturalness to ordered factor
  mutate(Naturalness=factor(Naturalness, 
                          levels=c(1,2,3), 
                          labels=c("Natural", "Semi-natural", "Anthropogenic"), 
                          ordered = T)) %>%  
  relocate(Forest:Naturalness, .after=ESY)

```

### Show Output


```{r, echo=F}
knitr::kable(header.oa %>%
               sample_n(20),
             caption="Example of header.oa [20 randomly selected plots shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```

## Metadata
Here, we try to organize this metadata information into a few meaningful fields. For each plot we provide information on:  

- Releve_author - Name of the person originally collecting the data in the field  
- Releve_coauthors - Names of additional persons originally collecting the data in the field 
- DB_Biblioreference - Bibliographic reference of the dataset the plot stems from
- Plot_Biblioreference - Bibliographic reference where the plot was first published, if any  
- Nr_table_in_publ - Number of the table reporting the plot in the publication where it was originally published, if any  
- Nr_releve_in_table - Plot number in the table where the plot was originally reported  
- Original_nr_in_database - Original plot number, in the database the plot stems from  
- Original_plotID - Only for nested plots  
- Original_subplotID - Only for nested plots. In case a plot is nested inside another  
- Project_name - Name of the project a specific plot stems from   
- Remarks - Any additional notes associated with a plot  
- GUID - Unique ID generated by Turboveg  


Import and parse plot level info.  
Before importing, need to seek and replace all quotation and double quotation marks, and escape them. Done via LINUX console
```{bash, engine.opts='-l', eval=F}
#not sure it works from markdown, works from console,though
sed "s/'/\\'/g" _data/PlotLevelInfo/TV3_PlotLevelInfo_Export.csv >  _data/PlotLevelInfo/TV3_PlotLevelInfo_Export_test.csv
sed 's/"/\\"/g' _data/PlotLevelInfo/TV3_PlotLevelInfo_Export_test.csv >  _data/PlotLevelInfo/TV3_PlotLevelInfo_Export_test2.csv
```

```{r}
plotinfo.raw <- read_delim("_data/PlotLevelInfo/TV3_PlotLevelInfo_Export_test2.csv", delim="\t", 
                           col_types = cols(
                             .default = col_character(),
                             PlotObservationID = col_double(),
                             PlotID = col_double(),
                             Country = col_character(),
                             `Nr. table in publ.` = col_character(),
                             `Nr. relevé in table` = col_character(),
                             Author = col_character(),
                             Remarks = col_character(),
                             `Original nr in database` = col_character(),
                             Collection = col_character(),
                             Dataset = col_character(),
                             SURVEY = col_character(),
                             Longitude = col_double(),
                             Latitude = col_double(),
                             `Location uncertainty (m)` = col_double(),
                             Dataset_1 = col_character(),
                             GUID = col_character(), 
                             DB_OWNER = col_character(),
                             ORIG_DB = col_character()
                           )) %>% 
  #drop empty field
  select(where(~ !(all(is.na(.)) | all(. == ""))))
```
Plot-level metadata information is stored in a heterogeneous manner across the datasets participating to sPlot. 
```{r}
colnames(plotinfo.raw)
```
In the following subsection, we try and harmonize the information from these multiple fields.

### Dataset Biblioreference
```{r, message=F}
#Import dataset-level BibTex reference list
bib.db <- bib2df("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/sPlot_References.bib")
#Import database-level information
databases <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/Databases.out.csv")

plotinfo.dbref <- header.oa %>% 
  dplyr::select(PlotObservationID, GIVD_ID) %>% 
  left_join(databases %>% 
              dplyr::select(GIVD_ID=`GIVD ID`, DB_BIBTEXKEY=BIBTEXKEY), 
            by="GIVD_ID")
```



### Plot Biblioreference
Data from Turobevg come with a dictionary of references. These references, however, are not formally formatted, but are simple strings of text. For the time being, we keep them like that.  
It would be more efficient to store the data using a dictionary style, where Biblioreferences are referred to with a symbol or short string, and reported in full in an associate reference list. 
```{r, message=F}
#Import biblioreference dictionary from TurboVeg3
Biblioref.raw <- read_delim("_data/PlotLevelInfo/BiblioReference_v2.txt", delim="\t", col_names = c("PlotObservationID", "Fullref"))
```
Bibliographic references could be parsed using the library [anystyle](https://github.com/inukshuk/anystyle), in ruby. Yet, the output need some additional cleaning. Below some code which might help for the scope. It's just an example and needs further refinements.  

Do some string modification before parsing with anystyle. Need to convert all words being completely upper case to lower case, with first letter uppercase.
```{r}
## Convert words being completely upper case to lower case, and mantain only first letter uppercase
## This improves considerably parsing using anystyle
.simpleCap <- function(x) {
  s <- strsplit(x, "-")[[1]]  
  s <- tolower(s)
  paste(toupper(substring(s, 1, 1)), substring(s, 2),
          sep = "", collapse = "-")
}

br1 <- Biblioref.raw %>% 
  distinct(Fullref) %>% 
  arrange(Fullref)
for(i in 1:nrow(br1)){
  tmp <- str_split(br1[i,], pattern = " ")[[1]]
  tochange <- str_detect(tmp, "^[:upper:]+$|^[:upper:]+,$|^[:upper:]+-[:upper:]+$") & str_count(tmp, pattern="[A-Za-z]|-")>1 #doesn't match non ASCII letters, though
  if(sum(tochange)>0){
    tmp[tochange] <- sapply(tmp[tochange], .simpleCap)
    br1[i,] <- paste(tmp, collapse=" ")
  }
}

#split in chunks with 300 refs each
nchunks <- ceiling(nrow(br1)/300)
iii <- 1:nrow(br1)
splitted <- split(iii, sort(iii%%nchunks))
```

```{r, eval=F}
##clean up before saving
filenames <- paste0("_data/PlotLevelInfo/Ref_to_parse_", 1:nchunks, ".txt")
if(any(file.exists(filenames))){
  #Delete file if it exists
  file.remove(filenames)
}

for(i in 1:nchunks){
  tmp <- br1$Fullref[splitted[[i]]]
  write_lines(tmp, paste0("_data/PlotLevelInfo/Ref_to_parse_", i, ".txt"), )
}
```
These references were submitted to the [anystyle](https://github.com/inukshuk/anystyle)'s web interface. Output was exported to bibTex.  
Reimport and match.
```{r, message=F, warning=F}
filenames <- paste0("_data/PlotLevelInfo/anystyle_", 1:nchunks, ".bib")
bib.list <- lapply(filenames, bib2df)
bib.df <- bind_rows(bib.list) %>% 
   select_if(function(x) !(all(is.na(x)) | all(x=="")))
br1.out <- bind_cols(Biblioref.raw %>% 
                   distinct(Fullref) %>% 
                   arrange(Fullref), bib.df)
```
Parse additional references not stored in TURBOVEG3's dictionary
```{r}
br2 <- plotinfo.raw %>%
  dplyr::select(`Biblio reference`) %>% 
  distinct(`Biblio reference`) %>% 
  arrange(`Biblio reference`) %>% 
  filter(!is.na(`Biblio reference`)) %>% 
  filter(!str_detect(`Biblio reference`, pattern ="^\\d+$"))

#split in chunks with 300 refs each
nchunks2 <- ceiling(nrow(br2)/300)
iii2 <- 1:nrow(br2)
splitted2 <- split(iii2, sort(iii2%%nchunks2))
```
Manually submit the files to [anystyle](https://github.com/inukshuk/anystyle)'s web interface. Output was exported to bibTex. 
```{r, eval=F}
##clean up before saving
filenames <- paste0("_data/PlotLevelInfo/Ref2_to_parse_", 1:nchunks2, ".txt")
if(any(file.exists(filenames))){
  #Delete file if it exists
  file.remove(filenames)
}

for(i in 1:nchunk2s){
  tmp <- br2$`Biblio reference`[splitted2[[i]]]
  write_lines(tmp, paste0("_data/PlotLevelInfo/Ref2_to_parse_", i, ".txt"), )
}
```
Reimport and match
```{r, message=F, warning=F}
filenames2 <- paste0("_data/PlotLevelInfo/anystyle2_", 1:nchunks2, ".bib")
bib.list <- lapply(filenames2, bib2df)
bib.df <- bind_rows(bib.list) %>% 
   select_if(function(x) !(all(is.na(x)) | all(x=="")))

br2.out <- bind_cols(br2, bib.df) %>% 
  rename(Fullref=`Biblio reference`)
```

Create a unique df with all formatted references and correct duplicated bibtexkeys
```{r}
#define helper function
rename.duplicates <- function(x){
  tick <- 1
  while(sum(duplicated(x)) > 0) {
    #print(tick)
    if (tick == 1) {x[duplicated(x)] <- paste0(x[duplicated(x)], tick, sep = "")}
    if (tick > 1) {
      x[duplicated(x)] <-paste0(str_sub(x[duplicated(x)], end = -2), #strip last character of string
               tick, sep ="")}
    tick <- tick + 1
  }
  return(x)
}

#fix duplicated bibtex keys
bib.oa <- bind_rows(br1.out, br2.out, bib.db)
bib.oa$BIBTEXKEY <- rename.duplicates(bib.oa$BIBTEXKEY)
```


```{ruby, eval=F, echo=F, engine.path = '~/.rubies/ruby-2.7.2/bin/ruby'}
#Check if I can use Ruby's `anystyle` library inside RMarkdown.  
#Parsing is in general pretty good, yet not perfect. I leave this on standby for the time being.

puts RUBY_VERSION
require "anystyle"
File.open("_data/PlotLevelInfo/BiblioReference.clean.txt", "r") do |file_handle|
    file_handle.each_line do |ref|
      File.open("_data/PlotLevelInfo/output.txt", mode:"a") {|f| f.write AnyStyle.parse ref }
    end
  end
```

```{r}
#select all fields in plotinfo.raw having biblioref info
plotinfo.biblio <- plotinfo.raw %>%
  dplyr::select(PlotObservationID, Country, 
                Biblioreference, `Biblio reference`, PUBL, THESIS) %>% 
  #keep only non-empty
  filter_at(.vars = vars(Biblioreference:THESIS), .vars_predicate = any_vars(!is.na(.))) %>% 
  ## attach full reference
  left_join(Biblioref.raw, by="PlotObservationID") %>% 
  #coalesce into a unique field
  mutate(Biblioreference=coalesce(Fullref, Biblioreference, `Biblio reference`, PUBL, THESIS)) %>% 
  dplyr::select(PlotObservationID, Biblioreference) %>% 
  left_join(bib.oa %>% 
              dplyr::select(Fullref, BIBTEXKEY), by=c("Biblioreference"="Fullref")) 
```
Biblioreference information exists for `r plotinfo.biblio %>% filter(!is.na(Biblioreference)) %>% nrow()` plots.


```{r, eval=F, echo=F}
### deprecated code

### now we can link each individual biblioreference to its own plot, the code below is not needed anymore.
### It could come handy, though, in case we dedcide to create a literature reference list (=dictionary)
### and refer to this list using codes. It would be a more efficient use of space.

#Create link to dictionary reference
#some of these are labels referring to the dictionary, some other are full records, which are fully replicated in the dictionary. I need to distinguish between the two
allrefs <- plotinfo.biblio %>% 
  distinct(Biblioreference) %>% 
  pull(Biblioreference)


## Auxiliary function to find the full reference, given a label
getmatch <- function(x, reflist){
  aa <- gsub(pattern="\\.", replacement="\\\\.", x=x)
  aa <- gsub(pattern="\\(", replacement="\\\\(", x=aa)
  aa <- gsub(pattern="\\)", replacement="\\\\)", x=aa)
  aa <- gsub(pattern="\\*", replacement="\\\\*", x=aa)
  out <- reflist[grep(pattern=paste0("^", aa), x = reflist)]
  if(length(out)==0) {
    return(NA)}
  if(length(out)==1) {
      return(out)
  }
  if(length(out)>1) {
    return("XXX - MULTIPLE MATCHES FOUND!")
  }
}

#find full references
biblio.dictionary <- plotinfo.biblio %>% 
  distinct(Biblioreference) %>% 
  mutate(Fullref=ifelse(Biblioreference %in% Biblioref.raw, 
                        Biblioreference, 
                        NA)) %>% 
  mutate(Label=ifelse(!is.na(Fullref), 
                      ## extract all character from string start to the end of the first set of numbers
                      str_extract(Fullref, "^\\D+\\(\\d+\\)|^\\D+\\d+"), 
                      Biblioreference)) %>% 
  mutate(Label=coalesce(Label, Biblioreference))  %>% 
  ## attach full reference based on label
  ## NOT FULLY functional, there are multiple matches in the dictionary
  ## asked Stephan to provide link between label and full reference
  rowwise() %>% 
  mutate(Fullref=ifelse(is.na(Fullref),
                        getmatch(`Label`, reflist=Biblioref.raw), 
                        Fullref
                        )) %>% 
  ungroup()

#check results
(n <- sample(1:nrow(biblio.dictionary), 1))
biblio.dictionary %>% slice(n) %>% glimpse()

# get output, ID, Biblioreference (=Label) & Full reference 
plotinfo.biblio2 <- plotinfo.biblio %>% 
  left_join(biblio.dictionary, by="Biblioreference") %>% 
  dplyr::select(-Biblioreference) %>% 
  dplyr::select(PlotObservationID, Biblioreference=Label, Fullref)

plotinfo.biblio2 %>% 
  sample_n(10)

plotinfo.biblio2 %>% 
  filter(Fullref=="XXX - MULTIPLE MATCHES FOUND!") %>% 
  nrow()
```


### Author
Coalesce columns reporting information on author
```{r}
plotinfo.author <- plotinfo.raw %>%
  dplyr::select(PlotObservationID, Country, 
                Author, Surveyor, COLLECTOR, PLOTAUTHOR, DATA_OWNER,AUTOR, AUTHORM,AUTOR_REL, AUTHORNAME, COAUTHORS) %>% 
  #keep only non-empty
  filter_at(.vars = vars(Author:COAUTHORS), .vars_predicate = any_vars(!is.na(.))) %>% 
  mutate(Author=coalesce(Author, Surveyor, COLLECTOR, PLOTAUTHOR, DATA_OWNER,AUTOR, AUTHORM,AUTOR_REL, AUTHORNAME)) %>% 
  dplyr::select(PlotObservationID, Releve_author=Author, Releve_coauthors=COAUTHORS)

#fix known issues
plotinfo.author <- plotinfo.author %>% 
  mutate(Releve_author=replace(Releve_author, 
                        list=Releve_author=="Udo Schickhoff *checking for initial", 
                        values="Udo Schickhoff"))
```
There are `r nrow(plotinfo.author)` plots having author information.  

### Project
Coalesce columns reporting information on project
```{r}
plotinfo.project <- plotinfo.raw %>%
  dplyr::select(PlotObservationID, Country, 
                Project, Dataset, SURVEY, PROJCTNAME, PROJ_NAME) %>% 
  #keep only non-empty
  filter_at(.vars = vars(Project:PROJ_NAME), .vars_predicate = any_vars(!is.na(.))) %>% 
  mutate(Project=coalesce(Project, Dataset, SURVEY, PROJCTNAME, PROJ_NAME )) %>% 
  dplyr::select(PlotObservationID, Project, -Country)
```
There are `r nrow(plotinfo.project)` plots having project level information.

### Numbering
Plot numbering in original databases, and if plot is a subplot of something else.
```{r}
plotinfo.number <- plotinfo.raw %>%
  dplyr::select(PlotObservationID, Country, 
                Nr_table_in_publ="Nr. table in publ.", Nr_releve_in_table="Nr. relevé in table",
                Original_nr_in_database="Original nr in database", PLOT, SUBPLOT, ORIG_ID,ORIG_ID_1,PLOTID, SUBPLOTID, ORIG_REL_N) %>% 
  #keep only non-empty
  filter_at(.vars = vars(Nr_table_in_publ:ORIG_REL_N), .vars_predicate = any_vars(!is.na(.))) %>% 
  mutate(PLOTID=coalesce(PLOT, PLOTID)) %>% 
  mutate(SUBPLOTID=coalesce(SUBPLOTID, SUBPLOT)) %>% 
  dplyr::select(-PLOT, -SUBPLOT) %>% 
  mutate(Original_nr_in_database=coalesce(Original_nr_in_database,ORIG_ID, ORIG_ID_1)) %>% 
  dplyr::select(-Country, -ORIG_ID, -ORIG_ID_1, -ORIG_REL_N, Original_plotID=PLOTID, Original_subplotID=SUBPLOTID)
```

### Recompile metadata
Recompile and explore plot-level info

```{r}
metadata.oa <- plotinfo.raw %>% 
  dplyr::select(PlotObservationID, Remarks, GUID) %>% 
  left_join(plotinfo.dbref, by="PlotObservationID") %>% 
  left_join(plotinfo.author, by="PlotObservationID") %>% 
  left_join(plotinfo.biblio, by="PlotObservationID") %>% 
  left_join(plotinfo.number, by="PlotObservationID") %>% 
  left_join(plotinfo.project, by="PlotObservationID") %>% 
  relocate(Remarks, .after=last_col()) %>% 
  relocate(GUID, .after=last_col())

```

```{r, echo=F}
knitr::kable(metadata.oa %>%
               sample_n(20) %>% 
               arrange(PlotObservationID),
             caption="Example of plot level info [20 randomly selected plots shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```
The vast majority of plots `r metadata.oa %>% filter_at(.vars = vars(Releve_author:Remarks), .vars_predicate = any_vars(!is.na(.))) %>% nrow()` out of `r nrow(metadata.oa)` have at least one entry among the selected plot level info.  

### Function to create reference list
Create function to create reference list, based on plot selection. Ideally the user will be able to conveniently create a citation report for the selection of plots he\\she is planning to use.
```{r}
sPlotOpen_citation <- function(IDs, level=c("plot", "database"), out.file){ 
  ## IDs - vector of PlotObservationIDs,
  ## level - At what level should the bibliorefrence be extracted? at the level of individual plot, or GIVD datasets?
  ## out.file - filename where to sink the reference list (also as a .bib file)
  require(dplyr)
  require(bib2df)
  if(level=="plot") {getkey <- "BIBTEXKEY"}
  if(level=="database") {getkey <- "DB_BIBTEXKEY"}
  bibtexkeys <- metadata.oa %>% 
    filter(PlotObservationID %in% IDs) %>% 
    distinct() %>% 
    pull(all_of(getkey))
  df2bib(bib.oa %>% 
           dplyr::select(-Fullref) %>% 
           filter(BIBTEXKEY %in% bibtexkeys), file = out.file)
  message("WARNING: This is a beta-version. References were parsed and converted automatically. They might need to be double-checked")
}
```
Demonstration
```{r}
sel.plots <- sample(header.oa$PlotObservationID, 100)
filename <- "_output/sPlot_BibText.bib"
sPlotOpen_citation(IDs=sel.plots, level="database", out.file = filename)

# show first 20 lines of output file
read_lines(filename, n_max = 20)
```



## DT Table

Complement taxon group using info from sPlot 3.0 and cross-matching congeneric species
```{r, warning=F}
DT.oa <- DT2 %>% 
  filter(PlotObservationID %in% unique(header.oa$PlotObservationID))
rm(DT2)

#load Backbonve sPlot 3.0
load("/data/sPlot/releases/sPlot3.0/Backbone3.0.RData")

## Assign genera to taxon group
taxon.groups <- DT.oa %>% 
  as.tbl() %>% 
  distinct(species) %>% 
  mutate(species2=species) %>% 
  separate(species2, into=c("Genus"), sep=" ") %>% 
  distinct(species, Genus) %>% 
  left_join(Backbone %>% 
              distinct(Name_short, `Taxon group`) %>% 
              rename(species=Name_short, 
                     Taxon.group=`Taxon group`) %>% 
              separate(species, into=c("Genus"), sep=" ") %>% 
              mutate(Taxon.group=as.character(Taxon.group)) %>% 
              mutate(Taxon.group=ifelse(Taxon.group=="Unknown", NA, Taxon.group)) %>% 
              distinct(Genus, .keep_all=T), 
            by="Genus") %>% 
  distinct(species, .keep_all = T) %>% 
  dplyr::select(-Genus)
  
DT2.oa <- DT.oa %>% 
  as.tbl() %>% 
  mutate(Taxon.group=as.character(Taxon.group)) %>% 
  mutate(Taxon.group=ifelse(Taxon.group=="Unknown", NA, Taxon.group)) %>% 
  mutate(species2=species) %>% 
  separate(species2, into=c("Genus"), sep=" ") %>% 
  ## cross complement internally, based on Genus
  left_join({.} %>% 
              filter(!is.na(Taxon.group)) %>% 
              #there may be conflict in attribution of specific genera to taxon group. Use majority vote
              group_by(Genus, Taxon.group) %>% 
              summarize(n=n(), .groups = 'drop') %>% 
              arrange(Genus, desc(n)) %>% 
              slice(1) %>% 
              dplyr::select(-n), 
            by="Genus") %>% 
  mutate(Taxon.group=coalesce(Taxon.group.x, Taxon.group.y)) %>% 
  dplyr::select(-Taxon.group.x, -Taxon.group.y) %>% 
  # attach taxon group info from Backbone 3.0
  left_join(taxon.groups, by="species") %>% 
  mutate(Taxon.group=coalesce(Taxon.group.x, Taxon.group.y)) %>% 
  dplyr::select(-Taxon.group.x, -Taxon.group.y, -Genus)

dim(DT2.oa)
table(DT2.oa$Taxon.group, exclude = NULL)
```

Clean up `DT2.oa` from all non vascular plant records and recalculate relative covers.

```{r}
DT2.oa <- DT2.oa %>% 
  filter(is.na(Taxon.group) | 
           !Taxon.group %in% c("Alga", "Lichen", "Moss")) %>% 
  left_join({.} %>%
              group_by(PlotObservationID) %>% 
              summarize(tot.cover=sum(Relative.cover), .groups = 'drop'), 
            by=c("PlotObservationID")) %>% 
  mutate(Relative.cover=Relative.cover/tot.cover) %>% 
  dplyr::select(-tot.cover)
```
The field `Layer` is always zero. Delete.
```{r}
DT2.oa <- DT2.oa %>% 
  dplyr::select(-Layer)
```

### Abundance and cover data

Species abundance information varies across datasets and plots. While for the large majority of plots abundance values are returned as percentage cover, there is a subset where abundance is returned with different scales. These are marked in the column `Cover code` as follows:
\newline \newline
- *x_BA* - Basal Area  
- *x_IC* - Individual count  
- *x_SC* - Stem count  
- *x_IV* - Relative Importance  
- *x_PF* - Presence Frequency  
- *x* - Presence absence  
\newline \newline
Still, it's not really intuitive that in case `Cover code` belongs to one of the classes above, then the actual abundance value is stored in the `x_` column. This stems from the way this data is stored in `TURBOVEG`.  
To make the cover data more user friendly, I simplify the way cover is stored, so that there are only two columns:  
`Ab_scale` - to report the type of scale used  
`Abundance` - to coalesce the cover\\abundance values previously in the columns `Cover %` and `x_`.  
\newline

This information is stored in a working copy of the DT table, before standardization to relative cover. Import it and filter only plots in open-access selection.

```{r}
DTraw <- read_delim(
  "/data/sPlot2.0/sPlot_2015_07_29_species.csv",
  delim = "\t",
  col_types = cols(
    PlotObservationID = col_double(),
    Taxonomy = col_character(),
    `Taxon group` = col_character(),
    `Taxon group ID` = col_double(),
    `Turboveg2 concept` = col_character(),
    `Matched concept` = col_character(),
    Match = col_double(),
    `Original taxon concept` = col_character(),
    Layer = col_double(),
    `Cover %` = col_double(),
    `Cover code` = col_character(),
    x_ = col_character()
  )) %>% 
  filter(PlotObservationID %in% header.oa$PlotObservationID)
```

Create `Ab_scale` field
```{r}
DTraw <- DTraw %>% 
  mutate(Ab_scale = ifelse(`Cover code` %in% 
                             c("x_BA", "x_IC", "x_SC", "x_IV", "x_PF", "x") & !is.na(x_), 
                           `Cover code`, 
                           "CoverPerc"))  
#mark pa plots
DTraw <- DTraw %>% 
  mutate(Ab_scale=replace(Ab_scale,
                    list=`Cover code`=="x" & `Cover %`==0,
                    values="pa"))
```

Fix some errors. There are some plots where all species have zeros in the field `Cover %`. Some of them are marked as p\\a (`Cover code=="x"`), but other not. Consider all this plots as presence\\absence. Most of them come from `USA_CVS` and `USA_VegBank`. 
```{r}
allzeroes <- DTraw %>% 
  filter(Ab_scale=="CoverPerc") %>% 
  group_by(PlotObservationID) %>% 
  summarize(allzero=all(`Cover %`==0), .groups = 'drop' ) %>% 
  filter(allzero==T) %>% 
  pull(PlotObservationID)
DTraw <- DTraw %>%
  mutate(`Cover code` = replace(`Cover code`,
    list = (PlotObservationID %in% allzeroes),
    values = "x")) %>%
  mutate(`Ab_scale` = replace(`Ab_scale`,
    list = (PlotObservationID %in% allzeroes),
    values = "pa"))
```
For p\\a plots, replace the field `Cover %` with NA, and assign 1 to the field `x_`. 
```{r}
DTraw <- DTraw %>% 
 mutate(x_=replace(x_,
                    list=Ab_scale=="pa",
                    values=1)) %>% 
  mutate(`Cover %`=replace(`Cover %`,
                    list=Ab_scale=="pa",
                    values=NA))
```

There are also some plots having different cover scales. They are not many, and are mostly in Brazil.  
Find these plots first:
```{r}
mixed <- DTraw %>% 
  distinct(PlotObservationID, Ab_scale) %>% 
  group_by(PlotObservationID) %>% 
  summarize(n=n(), .groups = 'drop') %>% 
  filter(n>1) %>% 
  pull(PlotObservationID) %>% 
  unique()
length(mixed)
```
Most of these plots are a mixture of trees, being measured based on Basal area, and herbs, for which only p\\a was recorded. Transform the `Cover %` of p\\a species to an arbitrary small number, i.e., 1.  
Note that the field `Abundance` is created only here.
```{r}
DTraw <- DTraw %>% 
  mutate(Ab_scale=replace(Ab_scale, 
                           list=(PlotObservationID %in% mixed & 
                                   Ab_scale=="CoverPerc"), 
                           values="pa")) %>%
  mutate(`Cover %`=replace(`Cover %`, 
                           list=PlotObservationID %in% mixed,
                           values=NA)) %>% 
  mutate(x_=replace(x_,  list=Ab_scale=="pa", values=1)) %>% 
  #Create additional field Abundance to avoid overwriting original data
  mutate(Abundance =ifelse(Ab_scale %in% c("x_BA", "x_IC", "x_SC", "x_IV", "x_RF", "pa"), 
                          x_, `Cover %`)) %>% 
  mutate(Abundance=as.numeric(Abundance))
```

Double check and summarize `Ab_scales`
```{r}
scale_check <- DTraw %>% 
  distinct(PlotObservationID, Layer, Ab_scale) %>% 
  group_by(PlotObservationID) %>% 
  summarise(Ab_scale_combined=ifelse(length(unique(Ab_scale))==1, 
                                     unique(Ab_scale), 
                                     "Multiple_scales"), 
            .groups = 'drop')

nrow(scale_check)== length(unique(DTraw$PlotObservationID))
table(scale_check$Ab_scale_combined, exclude=NULL)
```
Attach fields `Ab_scale` and `Abundance` to DT2.oa. Rename columns.

```{r}
DT2.oa <- DT2.oa %>% 
  left_join(DTraw %>% 
              dplyr::select(PlotObservationID, Matched.concept=`Matched concept`, Ab_scale, Abundance), 
            by=c("PlotObservationID", "Matched.concept")) %>% 
  dplyr::select(PlotObservationID, Species=species, Original_species=Matched.concept, 
                Taxon_group=Taxon.group, Original_abundance=Abundance, Abundance_scale=Ab_scale, Relative_cover=Relative.cover)
```

### Update individual datasets
There are two datasets whose species names need to be updated before releasing OA.


#### AF-CD-001 - Congo
Import updated data and convert to long format
```{r, message=F}
congo.new.raw <- read_csv("_data/Update_Congo/Kearsley_Yangambi_sPlot_subplots_v2.csv")

congo.new <- congo.new.raw %>% 
  mutate(BA=pi* ((`DBH (cm)`/100/2)^2)) %>% 
  group_by(Site, Species) %>% 
  summarize(BA=sum(BA), .groups="drop") %>% 
  bind_rows({.} %>% 
              separate(Site, into=c("Site", "Subplot", sep=" - ")) %>% 
              group_by(Site, Species) %>% 
              summarize(BA=sum(BA))) %>% 
  distinct() %>% 
  mutate(Site2=Site) %>% 
  separate(Site2, into=c("Plot", "Subplot")) %>% 
  mutate(Area=ifelse(!is.na(Subplot), 625, 10000)) %>% 
  mutate(BA.ha=BA/Area*10000) %>% 
  arrange(Site, Species) %>% 
  dplyr::select(Site, Plot, Subplot, Species, BA, BA.ha)
head(congo.new)
```
Assign PlotObservationID to plot codes
```{r}
### Data from Stephan 
header.TV <- read_delim(file = "_data/sPlot-2.1_header.csv", delim = "\t", 
                        col_types = cols(PlotObservationID = col_double(),
                                        PlotID = col_double(),
                                        `TV2 relevé number` = col_double(),
                                        `Original nr in database` = col_character(),
                                        ORIGDB_NR = col_character(),
                                        ORIGDB_NR_1 = col_character(),
                                        ORIG_REL_N = col_character(),
                                        Longitude = col_double(),
                                        Latitude = col_double(),
                                        `Location uncertainty (m)` = col_double(),
                                        Dataset = col_character()))

header.sel.TV <- header.oa %>%
  dplyr::select(PlotObservationID, GIVD_ID) %>% 
  left_join(header.TV %>% 
              dplyr::select(PlotObservationID, `Original nr in database`),
            by="PlotObservationID")

congo.new <- congo.new %>% 
  inner_join(header.sel.TV, by=c("Site"="Original nr in database")) %>% 
  relocate(PlotObservationID, .before=Site)
```

Correct species names based on sPlot v2.1 Backbone
```{r}
## load backbone
load("/data/sPlot/releases/sPlot2.1/backbone.splot2.1.try3.is.vascular.Rdata")

## join names from backbone to congo.new
congo.new <- congo.new %>% 
  mutate(Species=str_replace(Species, pattern=" sp.$", replacement="")) %>% 
  left_join(backbone.splot2.1.try3 %>% 
              dplyr::select(Species=Name_submitted, New_species=name.short.correct) %>% 
              distinct(), 
            by="Species") %>% 
  ##manually correct two mistakes in Backbone
  mutate(New_species=ifelse(New_species %in% c("Canarium schweinfurtii", "Prioria balsaminfera"),
                            Species, 
                            New_species)) %>% 
  ## delete unidentified species 
  filter(Species != "unknown")

## check species names to change, based on the backbone
congo.new %>% 
  filter(Species != New_species) %>% 
  distinct(Species, .keep_all=T)

### get all unmatched species and run through TPL
 tocheck <- congo.new %>% 
  filter(is.na(New_species)) %>% 
  pull(Species) %>% 
  unique()

 library(Taxonstand)
 checked <- TPL(tocheck)
 checked2 <- data.frame(old_species=tocheck) %>% 
   bind_cols(checked %>% 
               dplyr::select(New.Genus, New.Species)) %>% 
   replace_na(list(New.Genus="", New.Species="")) %>% 
   unite(New.Genus, New.Species, col=new_species, sep=" ") %>% 
   mutate(new_species=str_replace(new_species, pattern=" *$", replacement="")) %>% 
   mutate(old_species=as.character(old_species))

## assign unmatched old names to new names
congo.new <- congo.new %>% 
  left_join(checked2, 
            by=c("Species"="old_species")) %>% 
  mutate(New_species=coalesce(New_species, new_species)) %>% 
  dplyr::select(-new_species)
  
```

Format `congo.new` to match `DT2.oa`
```{r}
congo.out <- congo.new %>%
  rename(Original_abundance = BA.ha, 
         Original_species=Species) %>% 
  rename(Species=New_species) %>%
  mutate(Taxon_group = "Vascular plant") %>%
  mutate(Abundance_scale = "x_BA") %>%
  left_join({.} %>%
    group_by(PlotObservationID) %>%
    summarize(Tot_abundance = sum(Original_abundance),
      .groups = "drop"),
    by = "PlotObservationID") %>%
  mutate(Relative_cover = Original_abundance / Tot_abundance) %>% 
  dplyr::select(all_of(colnames(DT2.oa)))

## compare a random plot before and after replacement
plotsel <- sample(unique(congo.new$PlotObservationID), 1)
DT2.oa %>% filter(PlotObservationID==plotsel) %>% print(n=15)
congo.out %>% filter(PlotObservationID==plotsel) %>% print(n=15)
```
Replace entries in `DT2.oa`
```{r}
dim(DT2.oa)
DT2.oa <- DT2.oa %>% 
  filter(!PlotObservationID %in% (congo.out %>% 
                                   pull(PlotObservationID) %>% 
                                   unique())) %>% 
  bind_rows(congo.out) %>% 
  arrange(PlotObservationID, Species)
dim(DT2.oa)
```

#### AF-00-009 - Angola
Import updated data 
```{r}
angola.new.raw <- openxlsx::read.xlsx("_data/Update_Angola/TFO_DB.xlsx", sheet=1)

header.sel.TV <- header.oa %>%
  dplyr::select(PlotObservationID, GIVD_ID) %>% 
  left_join(header.TV %>% 
              dplyr::select(PlotObservationID, "TV2 relevé number"),
            by="PlotObservationID")

## REMEMBER TO double check if plot level total vegetation cover match to header!

## attach PlotObservation ID
angola.new <- angola.new.raw %>% 
  dplyr::select(Plot.number, Species.name, Cover.total) %>% 
  inner_join(header.sel.TV %>% 
               filter(GIVD_ID=="AF-00-009") %>% 
               dplyr::select(-GIVD_ID),
            by=c("Plot.number"="TV2 relevé number")) %>% 
## one plot missing from update
  dplyr::select(PlotObservationID, Species=Species.name, Cover=Cover.total)

## join names from backbone to congo.new
angola.new <- angola.new %>% 
  left_join(backbone.splot2.1.try3 %>% 
              dplyr::select(Species=names.sPlot.TRY, New_species=name.short.correct) %>% 
              distinct(), 
            by="Species") %>% 
  mutate(New_species=str_replace(New_species, " *$", "")) #strip whitespace at the end of species names

## check species names to change, based on the backbone
# angola.new %>% 
#   filter(Species != New_species) %>% 
#   distinct(Species, .keep_all=T)
# 
# angola.new %>% 
#   filter(is.na(New_species)) %>% 
#   distinct(Species, .keep_all=T)
# 
```

Out of the `r length(unique(angola.new$Species))` species contained in the Angola update, `r angola.new %>% distinct(Species, .keep_all=T) %>% filter(!is.na(New_species)) %>% nrow()` matched an entry in the backbone, while the remaining `r angola.new %>% distinct(Species, .keep_all=T) %>% filter(is.na(New_species)) %>% nrow()` returned `NA`. 

```{r, eval=F}
### get all unmatched species and run through TPL
tocheck <- angola.new %>%
  filter(is.na(New_species)) %>%
  pull(Species) %>%
  unique()
library(Taxonstand)
checked <- TPL(tocheck)
save(checked, file = "_data/Update_Angola/Species_Checked_TPL.RData")
```
```{r}
load(file = "_data/Update_Angola/Species_Checked_TPL.RData")
```

New `r checked %>% filter(Plant.Name.Index==T) %>% nrow()` matches found.
```{r}


checked2 <- checked %>%
  filter(Plant.Name.Index==T) %>% 
  dplyr::select(Taxon, New.Genus, New.Species) %>% 
  replace_na(list(New.Genus = "", New.Species = "")) %>%
  unite(New.Genus, New.Species, col = new_species, sep = " ") 

angola.new <- angola.new %>% 
  as_tibble() %>% 
  left_join(checked2, by=c("Species"="Taxon")) %>% 
  mutate(New_species=coalesce(New_species,new_species)) %>% 
  dplyr::select(-new_species)
```

There are still `r angola.new %>% filter(is.na(New_species)) %>% distinct(Species) %>% nrow()` unmatched species. Most of them haven't been yet identified, and only have working names, such as `r angola.new %>% filter(is.na(New_species)) %>% distinct(Species) %>% sample_n(3) %>% pull(Species) %>% paste(collapse="; ")` [Three randomly selected species]. Yet a few of these, at least have info about the family. Extract this.

```{r}
unmatched <- angola.new %>% filter(is.na(New_species)) %>% distinct(Species) %>% pull(Species)
unmatched <- data.frame(Species=unmatched, family=str_extract(unmatched, pattern='([^\\s]+aceae)'))

angola.new <- angola.new %>% 
  left_join(unmatched, by="Species") %>% 
  mutate(New_species=coalesce(New_species, family)) %>% 
  dplyr::select(-family)
```
There are still `r angola.new %>% filter(is.na(New_species)) %>% distinct(Species) %>% nrow()` unmatched species. Some of them can be manually parsed, at least at genus level

```{r}
species.dictionary <- c('Asparagus aff. nelsii x baumii' = "Protasparagus nelsii",
  'Asparagus spaerlich' = "Asparagus",
  'Baphia sp. geoxyle' = "Baphia",
  'Barleria like lanceolata' = "Barleria",
  'Brachiaria  132728' = "Brachiaria",
  'Bulbostylis sp. 132553' = "Bulbostylis",
  'Bulbostylis sp. 134794' = "Bulbostylis",
  'cf. Andropogon sp. 132765' = "Andropogon",
  'cf. Dalbergia 134918' = "Dalbergia",
  'Combretum Str imparapinnate krusselig 134690' = "Combretum",
  'Commelina pallidispatha' = "Commelina pallidispatha",
  'Crotalaria sp. Murray Hudson' = "Crotalaria",
  'Cyperus Simse gelb Festland' = "Cyperus",
  'Desmodium sp. 136411' = "Desmodium",
  'Diospyros pseudomespilus ssp. brevicalyx' = "Diospyros pseudomespilus",
  'Droogmannsia megalantha' = "Droogmansia megalantha",
  'einähriges Gras von gestern 132299' = "Poaceae",
  'Eragrostis kleinblütig fädig 132495' = "Eragrostis",
  'Fadogia flaum Spross 136500' = "Fadogia",
  'Fadogia Zwergstrauch Frucht rot 136530' = "Fadogia",
  'Gras branched Ähre 132297' = "Poaceae",
  'Gras non-cylindriflora' = "Poaceae",
  'Hafer, Haarkranz mit Knoten 132293' = "Poaceae",
  'Indigofera Rundblatt braunbehaart' = "Indigofera",
  'Kyllinga sp. 134793' = "Kyllinga",
  'Loudetia sp. 134798' = "Loudetia",
  'Mammutgras Bl breit' = "Poaceae",
  'Mammutgrass 133127' = "Poaceae",
  'Melinis sp.' = "Melinis",
  'Pavetta sp. 134685' = "Pavetta",
  'Phileptera nelsii' = "Philenoptera nelsii",
  'Pleiotaxis sp. doldig spitz' = "Pleiotaxis",
  'Pseudocarex rotgruen 134518' = "Poaceae",
  'Syzygium guineense ssp. barotsense' = "Syzygium guineense",
  'Terminalia serciea' = "Terminalia sericea",
  'Thesium von gestern' = "Thesium",
  'Tricalysia black glands' = "Tricalysia",
  'Triclaysia black glands' = "Tricalysia",
  'Tristachya sp. 132788' = "Tristachya",
  'Uapaca pinnat 134496b' = "Uapaca",
  'Uapaca schmalbltrg 134835' = "Uapaca",
  'Xyris gelb dick 135539' = "Xyris",
  'Xyris gelb groß binsenartig' = "Xyris",
  'Xyris goldgelb 132737' =   "Xyris"
)
species.dictionary <- data.frame(Species=names(species.dictionary), new_species=species.dictionary)  

angola.new <- angola.new %>% 
  left_join(species.dictionary, by="Species") %>% 
  mutate(New_species=coalesce(New_species, new_species)) %>% 
  dplyr::select(-new_species)

## exclude mosses
angola.new <- angola.new %>% 
  filter(!grepl(pattern="Moos|moos", x=Species))
```
Little can be done with the remaining `r angola.new %>% filter(is.na(New_species)) %>% distinct(New_species) %>% nrow()` species.

Format `angola.new` to match `DT2.oa`
```{r, warning=F}
angola.out <- angola.new %>%
  rename(Original_abundance = Cover, 
         Original_species=Species) %>% 
  rename(Species=New_species) %>%
  #attach taxon group from Backbone 3.0
  left_join(Backbone %>% 
              distinct(Name_sPlot_TRY, `Taxon group`) %>% 
              rename(Taxon_group=`Taxon group`), 
            by=c("Original_species"="Name_sPlot_TRY")) %>% 
  mutate(species2=Species) %>% 
  separate(species2, into=c("Genus"), sep=" ") %>% 
  ## cross complement internally, based on Genus
  left_join(DT2.oa %>% 
              distinct(Species, .keep_all=T) %>% 
              separate(Species, into=c("Genus"), sep=" ") %>% 
              filter(!is.na(Taxon_group)) %>% 
              distinct(Genus, Taxon_group),
            by="Genus") %>% 
  mutate(Taxon_group=coalesce(Taxon_group.x, Taxon_group.y)) %>% 
  dplyr::select(-Taxon_group.x, -Taxon_group.y) %>% 
  mutate(Taxon_group=ifelse(Taxon_group=="Unknown", NA, Taxon_group)) %>% 
  mutate(Abundance_scale = "CoverPerc") %>%
  # calculate relative cover
  left_join({.} %>%
    group_by(PlotObservationID) %>%
    summarize(Tot_abundance = sum(Original_abundance), .groups = "drop"),
    by = "PlotObservationID") %>%
  mutate(Relative_cover = Original_abundance / Tot_abundance) %>% 
  dplyr::select(all_of(colnames(DT2.oa))) %>% 
  #filter out species with zero abundance -> probably due to species aggregation after taxa identification
  filter(Original_abundance!=0)

## compare a random plot before and after replacement
plotsel <- sample(unique(angola.out$PlotObservationID), 1)
DT2.oa %>% filter(PlotObservationID==plotsel) %>% print(n=25)
angola.out %>% filter(PlotObservationID==plotsel) %>% print(n=25)



```

Replace entries in `DT2.oa`
```{r}
dim(DT2.oa)
DT2.oa <- DT2.oa %>% 
  filter(!PlotObservationID %in% (angola.out %>% 
                                   pull(PlotObservationID) %>% 
                                   unique())) %>% 
  bind_rows(angola.out) %>% 
  arrange(PlotObservationID, Species)
dim(DT2.oa)
```


### Correct known issues
```{r}
DT2.oa <- DT2.oa %>%
  mutate(Species = ifelse(Species == "lachenalii subsp.",
                          "Hieracium lachenalii",
                          Species)) %>%
  mutate(Species = ifelse(Species == "virgaurea subsp.",
                          "Solidago virgaurea",
                          Species)) %>%
  mutate(Species = ifelse(Species == "murorum subsp.",
                          "Hieracium murorum",
                          Species)) %>%
  mutate(Species = ifelse(Species == "dubius subsp.",
                          "Tragopogon dubius",
                          Species)) %>% 
  filter(is.na(Taxon_group) | Taxon_group != "Moss") 

# drop taxon_group column
DT2.oa <- DT2.oa %>% 
  dplyr::select(-Taxon_group)
```

### Show Output

```{r, echo=F}
knitr::kable(DT2.oa %>%
               filter(PlotObservationID %in% sample(header.oa$PlotObservationID, 3)),
             caption="Example of DT2.oa [3 randomly selected plots shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```


## CWM data

Load species level gap-filled trait data
```{r}
load("/data/sPlot2.0/TRY.all.mean.sd.3.by.genus.species.Rdata")
TRY <- TRY.all.mean.sd.3.by.genus.species
```

Merge species data table with traits, and calculate species coverage for each plot, both based on relative cover, and number of species having trait info.
```{r}
CWM.oa0 <- DT2.oa %>%
  as.tbl() %>%
  dplyr::select(PlotObservationID, Species, Relative_cover) %>%
  left_join(TRY %>%
              dplyr::rename(Species=StandSpeciesName) %>%
              dplyr::select(Species, LeafArea.mean:Wood.vessel.length.mean), 
            by="Species") %>% 
  rename_at(.vars=vars(ends_with(".mean")), 
            .funs=~gsub(pattern=".mean", replacement="", x=.))

# Calculate coverage for each trait in each plot
CWM.oa2 <- CWM.oa0 %>%
  mutate_at(.vars = vars(LeafArea), 
            .funs = list(~if_else(is.na(.),0,1) * Relative_cover)) %>%
  group_by(PlotObservationID) %>%
  summarize(TraitCoverage_cover=sum(LeafArea, na.rm=T),
            Species_richness=n(),
            TraitCoverage_pa=mean(LeafArea>0), 
            .groups = 'drop')
```

Calculate CWM and CWV for each trait in each plot
```{r, cache=T}
# Ancillary function to calculate CWV
variance2.fun <- function(trait, abu){
  res <- as.double(NA)
  #nam <- nam[!is.na(trait)]
  abu <- abu[!is.na(trait)]
  trait <- trait[!is.na(trait)]
  abu <- abu/sum(abu)
  if (length(trait)>1){
    # you need more than 1 observation to calculate
    # skewness and kurtosis
    # for calculation see 
    # http://r.789695.n4.nabble.com/Weighted-skewness-and-curtosis-td4709956.html
    m.trait <- weighted.mean(trait,abu)
    res <- sum(abu*(trait-m.trait)^2)
  }
  res
}

CWM.oa1 <- CWM.oa0 %>%
  group_by(PlotObservationID) %>%
  summarize_at(.vars= vars(LeafArea:Wood.vessel.length),
               .funs = list(CWM=~weighted.mean(., Relative_cover, na.rm=T), 
                            CWV=~variance2.fun(., Relative_cover)))

```
Assemble output
```{r}  
CWM.oa <- header.oa %>% 
  dplyr::select(PlotObservationID) %>% 
  left_join(CWM.oa2, by="PlotObservationID") %>% 
  left_join(CWM.oa1, by="PlotObservationID")

dim(CWM.oa)
```

Rename fields to follow convention
```{r}
CWM.oa <- CWM.oa %>% 
  rename_all(.funs=~gsub('\\.', '_', x = .))
```


# Figures and Tables
## Figure 1 - Geographic distribution of plots

Template of Global map
```{r, cache=T, results="hide", warning=F, message=F}
#download data from rnaturalearth package
countries <- ne_countries(returnclass = "sf") %>% 
  st_transform(crs = "+proj=eck4") %>% 
  st_geometry()
graticules <- ne_download(type = "graticules_15", category = "physical",
                          returnclass = "sf") %>% 
  st_transform(crs = "+proj=eck4") %>% 
  st_geometry()
bb <- ne_download(type = "wgs84_bounding_box", category = "physical",
                  returnclass = "sf") %>% 
  st_transform(crs = "+proj=eck4") %>% 
  st_geometry()

# create ggplot template of the world map
w3a <- ggplot() +
  geom_sf(data = bb, col = "grey20", fill = "white") +
  geom_sf(data = graticules, col = "grey20", lwd = 0.1) +
  geom_sf(data = countries, fill = "grey90", col = NA, lwd = 0.3) +
  coord_sf(crs = "+proj=eck4") +
  theme_minimal() +
  theme(axis.text = element_blank(), 
        legend.title=element_text(size=12), 
        legend.text=element_text(size=12),
        legend.background = element_rect(size=0.1, linetype="solid", colour = 1), 
        legend.key.height = unit(1.1, "cm"), 
        legend.key.width = unit(1.1, "cm")) +
  scale_fill_viridis()
```

Data Preparation for spatial plotting
```{r, cache=T, results="hide", warning=F, message=F}
header.sf <- SpatialPointsDataFrame(coords= header.oa %>% 
                                      select(Longitude, Latitude), 
                                    proj4string = CRS("+init=epsg:4326"), 
                                    data=data.frame(PlotObservationID=header.oa$PlotObservationID, 
                                                    Dataset=header.oa$Dataset)) %>% 
  st_as_sf() %>% 
  st_transform(crs = "+proj=eck4")
```

Map of plot distribution - Version 1 - Coloured point.  
Each colour represents a database. Please note there are not enough colours in the palette to represent all 103 datasets
```{r, fig.width=8, fig.height=6, fig.align="center", warning=F, message=F, cache=T}
w3a + 
  geom_sf(data=header.sf, aes(color=Dataset), pch="+", size=1, alpha=0.8) + # aes(col=Dataset),
  geom_sf(data = countries, col = "grey10", fill=NA, lwd = 0.3) + 
  theme(legend.position = "none")
```

Version 2  - hexagons
```{r, fig.width=8, fig.height=6, fig.align="center", message=F, cache=T}
header2 <- header.oa %>% 
  select(PlotObservationID, Latitude, Longitude) %>% 
  filter(!(abs(Longitude) >171 & abs(Latitude>70)))
dggs <- dgconstruct(spacing=300, metric=T, resround='down')

#Get the corresponding grid cells for each plot
header2$cell <- dgGEO_to_SEQNUM(dggs, header2$Longitude, header2$Latitude)$seqnum

#Calculate number of plots for each cell
header.dggs   <- header2 %>% 
  group_by(cell) %>% 
  summarise(value.out=log(n(), 10))

#Get the grid cell boundaries for cells 
grid   <- dgcellstogrid(dggs, header.dggs$cell, frame=F) %>%
  st_as_sf() %>% 
  mutate(cell = header.dggs$cell) %>% 
  mutate(value.out=header.dggs$value.out) %>% 
  st_transform("+proj=eck4") %>% 
  st_wrap_dateline(options = c("WRAPDATELINE=YES"))

## plotting
w3a + 
    geom_sf(data=grid, aes(fill=value.out),lwd=0, alpha=0.9)    +
    geom_sf(data = countries, col = "grey10", fill=NA, lwd = 0.3) + 
    scale_fill_viridis(
      name="# plots", breaks=0:5, labels = c("1", "10", "100",
                                             "1,000", "10,000", "100,000"), option="viridis" )

```

## Figure 2  Whittaker Biome Graph
Get climatic data
```{r}
load("/data/sPlot/releases/sPlot2.1/sPlot_header_chelsa_20161124.RData")
climate.oa <- climate %>% 
  filter(PlotID %in% header.oa$PlotObservationID) %>% 
  dplyr::select(-POINT_X, -POINT_Y) %>% 
  rename(PlotObservationID=PlotID)
```

```{r, fig.width=8, fig.height=5, fig.align="center", message=F, cache=T}
whittaker_base_plot() +
  theme_classic() + 
  geom_point(data=climate.oa %>% 
                filter(bio12<4500 & bio01>-11), #filter out for plotting reasons 
              aes(x=bio01, y=bio12/10), 
             alpha=1/3, 
             cex=1/15)
```


## Table 1 - Database level information
Import databases and create reference tags
```{r, message=F, warning=F}
#Import BibTex
bib.db <- bib2df("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/sPlot_References.bib")
#Import database-level information
databases <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/Databases.out.csv")

# create citation tags that can be picked up by Manubot
databases <- databases %>% 
  left_join(bib.db %>% 
              dplyr::select(BIBTEXKEY, DOI, URL), 
            by="BIBTEXKEY") %>% 
  mutate(tag=NA) %>% 
  rowwise() %>% 
  mutate(tag=ifelse(!is.na(DOI), 
                    paste0("@doi:", DOI), 
                    tag)) %>% 
  mutate(tag=ifelse( (is.na(tag) & `GIVD ID` %in% unique(header.oa$GIVD_ID) & !is.na(Citation)), 
                     paste0("@", word(Citation, 1)), 
                     tag)) %>% 
  dplyr::select(-DOI, -URL, -BIBTEXKEY)
  

```



Create Table 1

```{r}
table1 <- databases %>% 
  filter(`Still in sPlot`==T, 
         Via!="Aggregator") %>% 
  dplyr::select(-Via, -`Still in sPlot`, -label) %>% 
  distinct() %>% 
  left_join(header.oa %>% 
              group_by(GIVD_ID) %>% 
              summarize(contributed_plots=n(), .groups = 'drop'), 
            by=c("GIVD ID"="GIVD_ID")) %>% 
  filter(!is.na(contributed_plots)) %>% 
  replace_na(list(tag="",
                  `Deputy custodian`="")) %>% 
  dplyr::select(`GIVD ID`, `Dataset name`=`DB_name GIVD`,  Custodian, `Deputy custodian`, `Nr. OA plots` = contributed_plots, Ref=tag) 


write_csv(table1, "_output/Table1_Databases.csv")
```

```{r, echo=F}
knitr::kable(table1%>% 
               slice(1:20),
             caption="Table 1 - Database level information [only first 20 rows shown]") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```


## Table 2 - Metadata and environmental data included in header  
Define unit of measurements for columns
```{r}
um <- c('Latitude'='° (WGS84)',
'Longitude'='° (WGS84)',
'Location_uncertainty'='m',
'Releve_area'='m^2^',
'Elevation'='m a.s.l.',
'Aspect'='°',
'Slope'='°',
'Date_of_recording' = 'dd-mm-yyyy',
'Cover_total'='%',
'Cover_tree_layer'='%',
'Cover_shrub_layer'='%',
'Cover_herb_layer'='%',
'Cover_moss_layer'='%',
'Cover_lichen_layer'='%',
'Cover_algae_layer'='%',
'Cover_litter_layer'='%',
'Cover_bare_rocks'='%',
'Cover_cryptogams'='%',
'Cover_bare_soil'='%',
'Height_trees_highest'='m',
'Height_trees_lowest'='m',
'Height_shrubs_highest'='m',
'Height_shrubs_lowest'='m',
'Height_herbs_average'='cm',
'Height_herbs_lowest'='cm',
'Height_herbs_highest' = 'cm')
um <- data.frame(Variable=names(um), `Unit of Measurement`=um)

```

Create table 2 
```{r}
table2 <- header.oa %>% 
  dplyr::summarize_at(.vars=vars(!starts_with("PlotObservationID")),
               .funs = list(xxxNo.records=~sum(!is.na(.)),
                            xxxType.of.variable=~ifelse("logical" %in% class(.), "b",
                                           ifelse("ordered" %in% class(.), 
                                                 "o", 
                                                  ifelse(any(class(.) %in% c("character", "factor")), 
                                                         "n",
                                                         ifelse(class(.)=="Date",
                                                                "d",
                                                                "q")))),
                            xxxLevels=~(ifelse(is.numeric(.)|lubridate::is.Date(.), 
                                               paste(range(., na.rm=T), collapse=" - "),
                                               ifelse(is.ordered(.), 
                                                      paste(paste(1:nlevels(.), 
                                                                  levels(.), sep=" = "), collapse=", "),
                                                      ifelse(is.factor(.), 
                                                              paste(levels(.), collapse=", "),
                                                              ifelse(is.logical(.),
                                                                     paste(names(table(.)), "=",table(.),
                                                                           collapse="; "),
                                                                     ""))))))) %>%
  gather(key="Variable") %>% 
  separate(Variable, into = c("Variable", "feature"), sep="_xxx") %>% 
  spread(key=feature, value = value) %>% 
  rename(`Range/Levels`=Levels) %>% 
  mutate(Variable=factor(Variable, levels=colnames(header.oa))) %>% 
  arrange(Variable) %>% 
  left_join(um, by="Variable") %>% 
  mutate(Unit.of.Measurement=as.character(Unit.of.Measurement)) %>% 
  replace_na(list(Unit.of.Measurement="")) %>% 
  dplyr::select(Variable, `Range/Levels`, 
                `Unit of Measurement`=Unit.of.Measurement, 
                `Nr. Records`=No.records, `Type`=Type.of.variable)

write_csv(table2, "_output/Table2_header.csv")
```

```{r, echo=F}
knitr::kable(table2,
             caption="Table 2 - Variables in header") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                  full_width = F, position = "center")
```

# Save Ouput
```{r}
path <- "_sPlotOpenDB"
save(DT2.oa, header.oa, metadata.oa, CWM.oa, bib.oa, sPlotOpen_citation, file = file.path(path, "sPlotOpen.RData"))

## Export to csv files
write_delim(DT2.oa, file = file.path(path, "sPlotOpen_DT.txt"), delim="\t")
write_delim(header.oa, file = file.path(path, "sPlotOpen_header.txt"), delim="\t")
write_delim(metadata.oa, file = file.path(path, "sPlotOpen_metadata.txt"), delim="\t")
write_delim(CWM.oa, file = file.path(path, "sPlotOpen_CWM_CWV.txt"), delim="\t")
df2bib(bib.db %>% 
         #bind db level and plot level references into a single bib file
         bind_rows(bib.oa %>%
                     dplyr::select(-Fullref)), 
       file = file.path(path, "sPlotOpen_references.bib"))

#export list of PlotObservationIDS
write_delim(header.oa %>% dplyr::select(PlotObservationID), file = "_output/Plot_list.txt")
```


## Sink tables for Manubot
```{r}
out.file <- "_output/91.ManubotTables.md"
readr::write_lines("## Supplementary Material {.page_break_before}\n", file = out.file)
readr::write_lines("Table: List of databases contributing to the open access dataset extracted from the sPlot database. Databases are ordered based on their ID in the Global Index of Vegetation Databases (GVID ID). {#tbl:Table1 tag='1'}\n", file = out.file, append=T)
readr::write_lines("\n \n", file = out.file, append=T)
kable1 <- kable(table1, format = "markdown")
## fix header table 1
kable1[2] <- "|:------------|:--------------------------------------------|:--------------------|:--------------------|--------:|:--------|"
readr::write_lines(kable1, file = out.file, append=T)
readr::write_lines("\n \n \n", file = out.file, append=T)
readr::write_lines("Table: Description of the variables contained in the ‘header’ matrix, together with their range (if numeric) or possible levels (if nominal or binary). Variable types can be n - nominal (i.e., qualitative variable), o - ordinal, q - quantitative, or b - binary (i.e., boolean), or d - date. {#tbl:Table2 tag='2'}\n", file = out.file, append=T)
kable2 <- kable(table2, format = "markdown")
## fix header table 2
kable2[2] <- "|:---------------------------|:-------------------------------------------------------------|:-------------------|:-----------|:-----|"
readr::write_lines(kable2, file = out.file, append=T)
```

## Create list of coauthors
Here, we create a preliminary list of coauthors, and format their affiliations to Manubot's standards.
```{r echo = T, results = 'hide', message=F}
library(stringr)
allroles <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/roles.csv")
allaffiliations <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/Affiliations.csv") %>% 
  left_join(allroles %>% 
                dplyr::select(Name,Surname), 
              by="Name")

first <- allaffiliations %>% 
  filter(Name %in% c("Francesco Maria Sabatini", "Jonathan Lenoir")) %>% 
  arrange(Name)
##third author still to code Tarek Habab
third <- tibble(Name="Tarek Hattab",
                           `E-Mail`="Tarek.Hattab@ifremer.fr",
                            ORCID="0000-0002-1420-5758",
                           `Department/Institute/Faculty`="MARBEC",
                           `University/Institution`="University of Montpellier, CNRS, IFREMER and IRD",
                           Town="Sète",
                           Country="France", 
                           Surname="Hattab")

custodians <- unique(table1$Custodian)
core <- allaffiliations %>% 
  filter(Name %in% (allroles %>%
           filter(`Core team` == T) %>%
           filter(!Surname %in% c("Bruelheide", "Sabatini", "Lenoir")) %>%
           pull(Name))) %>% 
  arrange(Surname) 
last <- allaffiliations %>% 
  filter(Name=="Helge Bruelheide")

affiliations <- first %>% 
  bind_rows(third) %>% 
  bind_rows(core) %>% 
  bind_rows(allaffiliations %>% 
      filter(Name %in% custodians) %>%
      filter(!Name %in% core$Name) %>%
      filter(!Name %in% first$Name) %>%
      filter(!Name %in% last$Name) %>% 
      bind_rows(
        tibble(
          Name = "Guillermo Hinojos Mendoza",
          `E-Mail` = "ghinojos@asessc.net",
          `Department/Institute/Faculty` = "Pépinière d’Entreprises l’Espélidou, Parc d’Activités du Vinobre",
          `University/Institution` = "ASES Ecological and Sustainable Services",
          Street = "555 Chemin des Traverses, Lachapelle-sous-Aubenas",
          `Postal code` = "07200",
          Town = "Aubenas",
          Country = "France",
          Surname = "Hinojos Mendoza"
        )
      ) %>%
      bind_rows(allaffiliations %>%
          filter(Name == "Elizabeth Kearsley") %>%
          mutate(
            `Department/Institute/Faculty` =
              replace(
                `Department/Institute/Faculty`,
                list = Name == "Elizabeth Kearsley",
                values =
                  "Department Environment, Computational and Applied Vegetation Ecology (UGent-CAVELab)"
              )) %>% 
          mutate(Surname = "Kearsley")) %>%
      bind_rows(
        tibble(
          Name = "Wannes Hubau",
          Sequence_affiliations = c(1, 2),
          `E-Mail` = "wannes.hubau@ugent.be",
          `Department/Institute/Faculty` = c(
            "Department Environment, Laboratory of Wood Biology (UGent-WoodLab)",
            "Service of Wood Biology"
          ),
          `University/Institution` = c("Ghent University", "Royal Museum for Central Africa"),
          Street = c("Coupure Links 653", "Leuvensesteenweg 13"),
          `Postal code` = c("9000", "3080"),
          Town = c("Ghent", "Tervuren"),
          Country = "Belgium",
          Surname = "Hubau"
        )
      ) %>%
      bind_rows(
        tibble(
          Name = "Marijn Bauters",
          Sequence_affiliations = c(1, 2),
          `E-Mail` = "marijn.bauters@ugent.be",
          `Department/Institute/Faculty` =
            c(
              "Department Green chemistry and technology, Isotope Bioscience laboratory (UGent-ISOFYS)",
              "Department Environment, Computational and Applied Vegetation Ecology (UGent-CAVELab)"
            ),
          `University/Institution` = "Ghent University",
          Street = "Coupure Links 653",
          `Postal code` = "9000",
          Town = "Ghent",
          Country = "Belgium",
          Surname = "Bauters"
        )
      ) %>% 
    arrange(Surname, Sequence_affiliations)) %>%  
  bind_rows(last) %>% 
  dplyr:::select(name=Name, email=`E-Mail`, orcid=ORCID, everything(), -Surname, -`Second E-Mail`) %>% 
    replace_na(list(`Department/Institute/Faculty`="", Street="", `Postal code`="", Town="",   Country="" )) %>% 
  unite(`University/Institution`, `Department/Institute/Faculty`, Street:Country, sep = ", ", col="affiliations", remove=T) %>% 
  mutate(affiliations=str_replace_all(string = affiliations, pattern=", , ", replacement = ", ")) %>% 
  ## exclude authors who declined offer
  filter(!name %in% c("Marten Winter", "Ching-Feng Li", "Kim Sarah Jacobsen"))


## function to format name, orcid, email and affiliation info into the metadata.yaml standard for manubot
create.yaml <- function(x, file.output){
  tmp <- affiliations %>%
    mutate(github="") %>% 
    filter(name==x) %>% 
    pivot_longer(!Sequence_affiliations, names_to = "tag") %>%
    arrange(Sequence_affiliations) %>% 
    dplyr::select(-Sequence_affiliations) %>% 
    mutate(tag=factor(tag, levels=c("github", "name", "orcid", "email", "affiliations"))) %>% 
    distinct() %>% 
    bind_rows(data.frame(tag="affiliations", 
                         value=paste0("\n      - ", 
                                      paste({.} %>% 
                                              filter(tag=="affiliations") %>% 
                                              pull(value),
                                            collapse="\n      - ")))) %>% 
    group_by(tag) %>% 
    slice(n()) %>% 
    ungroup() %>% 
    mutate(tag=as.character(tag)) %>% 
    mutate(tag=ifelse(tag=="github", "  - github", paste0("    ", tag))) %>% 
    filter(!is.na(value)) %>%
    unite(tag:value,
          sep = ": ",
          col = "newtag",
          remove = T) %>% 
    mutate(newtag=str_remove(newtag, pattern = '"')) %>% 
    mutate(newtag=str_remove(newtag, pattern = '"')) %>% 
    mutate(newtag=str_replace_all(string = newtag, pattern=", , ", replacement = ", ")) %>% 
    mutate(newtag=str_replace_all(string = newtag, pattern=", , ", replacement = ", "))
    write_lines(tmp[[1]], file = file.output, append=T) 
}

affi.out <- "_output/affiliations_yaml.txt" #create empty affiliation file
##populate yaml file with affiliation info
write_lines("", file = affi.out)
lapply(affiliations %>% 
         dplyr::select(name) %>% 
         distinct() %>% 
         pull(name), create.yaml, affi.out)
```
Create list of email addresses

```{r}
email <- affiliations %>% 
  dplyr::select(name, email) %>% 
  distinct() %>% 
## add additional coauthors
  bind_rows(data.frame(name="Tarek Hattab", email="tarek.Hattab@ifremer.fr")) %>%
  bind_rows(data.frame(name="Elizabeth Kearsley", email="elizabeth.kearsley@ugent.be")) %>% 
  mutate(export = paste0(name, " <", email, ">")) %>% 
  dplyr::select(export)
write_delim(email, file = "_output/Author_email.txt", delim="/t")

## approve submission

approve.checklist <- affiliations %>% 
  distinct(name) %>% 
  arrange(name) %>% 
  mutate(name=paste0(" - [ ] ", name))
write_delim(approve.checklist, file = "_output/Author_checklist.txt", delim="/t" )


## Create email list for Opt-ins
roles <- read_csv("/data/sPlot/users/Francesco/_sPlot_Management/Consortium/roles.csv")
email.optins <- roles %>% 
  filter(`Still in sPlot`) %>% 
  arrange(Surname) %>% 
  left_join(allaffiliations, by="Name") %>% 
  dplyr::select(Name, email=`E-Mail`) %>% 
  distinct() %>% 
  filter(!Name %in% affiliations$name) %>% 
  mutate(export = paste0(Name, " <", email, ">")) %>% 
  dplyr::select(export)

write_delim(email.optins, file = "_output/Optins_email", delim="/t" )
        


```



# SessionInfo
```{r}
sessionInfo()
```

